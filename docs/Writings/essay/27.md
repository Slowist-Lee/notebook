# HPCWeek - 2025

> [!abstract]
> å‚èµ›Writeup - rk 17 è™½ç„¶æ²¡æœ‰åæ¬¡â€¦â€¦ä½†æ˜¯ç¬¬ä¸€æ¬¡åšæ„Ÿè§‰å·²ç»å°½åŠ›äº†ã€‚

çºªå¿µï¼š

![](28d4b7a950f4e1beaf139fd240b8d84e.png)

![|300](Pasted%20image%2020251026202940.png)
## ç¯å¢ƒé…ç½®ç›¸å…³

### ssh è¿æ¥

#### 1. åœ¨ Windows ä¸ŠæŸ¥æ‰¾ä½ å·²é…ç½®çš„ SSH Key

1.  æ‰“å¼€æ–‡ä»¶èµ„æºç®¡ç†å™¨ã€‚
2.  åœ¨åœ°å€æ ä¸­è¾“å…¥ `%USERPROFILE%\.ssh` ç„¶åæŒ‰å›è½¦é”®ã€‚
    *   `%USERPROFILE%` æ˜¯ä¸€ä¸ªç³»ç»Ÿå˜é‡ï¼Œå®ƒä¼šè‡ªåŠ¨æŒ‡å‘ä½ å½“å‰ç”¨æˆ·çš„æ–‡ä»¶å¤¹ï¼Œä¾‹å¦‚ `C:\Users\YourUsername`ã€‚
3.  è¿›å…¥ `.ssh` æ–‡ä»¶å¤¹åï¼Œä½ ä¼šçœ‹åˆ°ä¸€äº›æ–‡ä»¶ã€‚è¿™äº›å°±æ˜¯ä½ çš„ SSH Key æ–‡ä»¶ï¼š
    *   `id_rsa` æˆ– `id_ed25519`: è¿™æ˜¯ä½ çš„**ç§é’¥ (Private Key)**ã€‚ **ç»å¯¹ä¸è¦æ³„éœ²æˆ–åˆ†äº«è¿™ä¸ªæ–‡ä»¶ï¼**
    *   `id_rsa.pub` æˆ– `id_ed25519.pub`: è¿™æ˜¯ä½ çš„**å…¬é’¥ (Public Key)**ã€‚è¿™ä¸ªæ–‡ä»¶å¯ä»¥å®‰å…¨åœ°åˆ†äº«ç»™ä½ éœ€è¦è¿æ¥çš„æœåŠ¡å™¨ï¼ˆå¦‚ GitHub, GitLab, æˆ–ä½ çš„äº‘ä¸»æœºï¼‰ã€‚
    *   `known_hosts`: è¿™ä¸ªæ–‡ä»¶è®°å½•äº†ä½ æ›¾ç»è¿æ¥è¿‡çš„æœåŠ¡å™¨çš„æŒ‡çº¹ï¼Œç”¨äºé˜²æ­¢ä¸­é—´äººæ”»å‡»ã€‚
    *   `config`: (å¯é€‰) è¿™æ˜¯ä¸€ä¸ªé…ç½®æ–‡ä»¶ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥ä¸ºä¸åŒçš„ä¸»æœºè®¾ç½®åˆ«åå’Œç‰¹å®šçš„è¿æ¥å‚æ•°ã€‚

#### 2. ZJULab é…ç½® ssh

åœ¨ [è¿™é‡Œ](https://git.zju.edu.cn/-/user_settings/ssh_keys) å¤åˆ¶`id_rsa.pub`ã€‚

#### 3. ç»ˆç«¯ ssh è¿æ¥

![](Pasted%20image%2020251016174439.png)

### Vscode in WSL

#### å¼€æƒé™

```bash
slowist@Slowist:/home/HPC$ sudo chown -R slowist:slowist /home/HPC
```

## Quine

[ã€ç¿»è¯‘ã€‘Quine - è‡ªæˆ‘å¤åˆ¶çš„ç¨‹åºï¼ˆä¸Šï¼‰ - çŸ¥ä¹](https://zhuanlan.zhihu.com/p/549183520)

[ç¬¨æ–¹æ³•å†™Quine](https://blog.mistivia.com/posts/2024-09-21-quine/)

â€œQuineâ€ ä¹Ÿå¯ç§°ä¸º "selfrep"ï¼Œæ˜¯ä¸€ä¸ªè®¡ç®—æœºç¨‹åºï¼Œæ‰§è¡Œåï¼Œæ‰“å°å‡ºè‡ªèº«æºç ã€‚

é¦–å…ˆå®šä¹‰å­—ç¬¦ä¸²`*DNA*`ã€‚è¿™é‡Œæˆ‘ä»¬ä¸çŸ¥é“â€œDNAâ€çš„å†…å®¹ï¼Œæ‰€ä»¥å…ˆç”¨emojiç¬¦å·ä»£æ›¿ã€‚å› ä¸ºè¿™ä¸ª
å­—ç¬¦ä¸²é‡Œé¢åŒ…å«äº†ä¸¤éƒ¨åˆ†å†…å®¹ï¼šå¤´å’Œå°¾ï¼Œæˆ‘ä»¬å‡è®¾å¤´æ˜¯è€è™ï¼Œå°¾å·´æ˜¯è›‡ï¼š

```python
dna = 'ğŸ±,ğŸ'
```

ç„¶åæŠŠå¤´å’Œå°¾å·´å–å‡ºæ¥ï¼š

```python
head, tail = dna.split(',')
```

å› ä¸ºæˆ‘ä»¬æ‰“ç®—ç”¨16è¿›åˆ¶ç¼–ç ï¼Œæ‰€ä»¥è¿™é‡Œè¦æŠŠå¤´å’Œå°¾éƒ½ç”¨16è¿›åˆ¶è§£ç æ¢å¤æˆåŸæ¥çš„æ ·å­ï¼š

```python
head = bytes.fromhex(head).decode('utf-8')
tail = bytes.fromhex(tail).decode('utf-8')
```

æœ€åï¼Œæˆ‘ä»¬æŠŠå¤´ã€DNAã€å°¾å·´ï¼Œè¿™ä¸‰éƒ¨åˆ†æ‹¼æ¥èµ·æ¥ï¼Œä¸€èµ·è¾“å‡ºï¼š
```python
print(head + dna + tail)
```

ç°åœ¨çš„ç¨‹åºæ˜¯è¿™æ ·çš„ï¼š

```python
dna = 'ğŸ±,ğŸ'
head, tail = dna.split(',')
head = bytes.fromhex(head).decode('utf-8')
tail = bytes.fromhex(tail).decode('utf-8')
print(head + dna + tail)
```

ç±»ä¼¼çš„æ€è·¯å†™Shell

```shell
dna='646e613d27,270d0a4946533d272c273b20736574202d2d2024646e613b20686561643d24313b207461696c3d24320d0a686561643d24286563686f2022246865616422207c20787864202d72202d70290d0a7461696c3d24286563686f2022247461696c22207c20787864202d72202d70290d0a6563686f2022246865616424646e61247461696c22'

IFS=','; set -- $dna; head=$1; tail=$2

head=$(echo "$head" | xxd -r -p)

tail=$(echo "$tail" | xxd -r -p)

echo "$head$dna$tail"
```

## Parallel Compress

### 1. è·‘é€šBaseline

ä¸‹è½½Baselineï¼Œå®‰è£…ä¾èµ–ï¼Œç„¶åmake

```bash
slowist@Slowist:/home/HPC/parallel_compress$ tar -xzf baseline.tar.gz
slowist@Slowist:/home/HPC/parallel_compress$ sudo apt install libhts-dev
slowist@Slowist:/home/HPC/parallel_compress$ sudo apt install gcc
slowist@Slowist:/home/HPC/parallel_compress/baseline$ sh compile.sh
rm -f compress
gcc -Wall -Wextra -O3 -fopenmp -o compress compress.c -lhts -lpthread
slowist@Slowist:/home/HPC/parallel_compress/baseline$ ./compress
Usage: ./compress <infile> <outfile>
```

å¯ä»¥çœ‹åˆ°ä¸€èˆ¬çš„æ‰§è¡Œï¼Œç”±äºæ²¡æœ‰è¾“å…¥è¾“å‡ºæ˜¯ä¸è¡Œçš„ã€‚åœ¨GPTçš„æŒ‡å¯¼ä¸‹éšæœºç”Ÿæˆ512Mæ–‡ä»¶ï¼š

```bash
slowist@Slowist:/home/HPC/parallel_compress/baseline$ dd if=/dev/urandom of=test.dat bs=1M count=512
512+0 records in
512+0 records out
536870912 bytes (537 MB, 512 MiB) copied, 1.29533 s, 414 MB/s
```

è‡³æ­¤Baselineè·‘é€šï¼›

### 2. `htslib` æä¾›æ¥å£åŠ é€Ÿ

æ ¹æ®é¢˜ç›®æç¤ºï¼Œå»æ‰¾Cæ¥å£çš„å®šä¹‰ï¼›

å®˜æ–¹æ–‡æ¡£ï¼š[here](htslib/htslib/bgzf.h at develop Â· samtools/htslib](https://github.com/samtools/htslib/blob/develop/htslib/bgzf.h#L378) åœ¨Geminiçš„å¸®åŠ©ä¸‹è¿˜æ˜¯çœ‹å¾—æ‡‚çš„ã€‚

æ‰¾åˆ°`bgzf_thread_pool`çš„å‡½æ•°å®šä¹‰ï¼š

```c
int bgzf_thread_pool(BGZF *fp, hts_tpool *pool, int qsize) {
    // No gain from multi-threading when not compressed
    if (!fp->is_compressed)
        return 0;

    mtaux_t *mt;
    mt = (mtaux_t*)calloc(1, sizeof(mtaux_t));
    if (!mt) return -1;
    fp->mt = mt;

    mt->pool = pool;
    mt->n_threads = hts_tpool_size(pool);
    if (!qsize)
        qsize = mt->n_threads*2;
    if (!(mt->out_queue = hts_tpool_process_init(mt->pool, qsize, 0))) {
        free(mt);
        return -1;
    }
    hts_tpool_process_ref_incr(mt->out_queue);

    mt->job_pool = pool_create(sizeof(bgzf_job));

    pthread_mutex_init(&mt->job_pool_m, NULL);
    pthread_mutex_init(&mt->command_m, NULL);
    pthread_mutex_init(&mt->idx_m, NULL);
    pthread_cond_init(&mt->command_c, NULL);
    mt->flush_pending = 0;
    mt->jobs_pending = 0;
    mt->free_block = fp->uncompressed_block; // currently in-use block
    mt->block_address = fp->block_address;
    pthread_create(&mt->io_task, NULL,
                   fp->is_write ? bgzf_mt_writer : bgzf_mt_reader, fp);

    return 0;
}
```


```c
int bgzf_thread_pool(BGZF *fp, hts_tpool *pool, int qsize);
```

*   **`BGZF *fp`**: ä¸€ä¸ªå·²ç»é€šè¿‡ `bgzf_open()` æ‰“å¼€çš„BGZFæ–‡ä»¶å¥æŸ„ã€‚å¿…é¡»æ˜¯ä»¥å†™å…¥ï¼ˆ"w"ï¼‰æˆ–è¯»å–ï¼ˆ"r"ï¼‰æ¨¡å¼æ‰“å¼€çš„ã€‚
*   **`hts_tpool *pool`**: æŒ‡å‘ä¸€ä¸ªå·²ç»åˆå§‹åŒ–çš„HTSlibçº¿ç¨‹æ± çš„æŒ‡é’ˆã€‚**è¿™æ˜¯å…³é”®**ï¼šè°ƒç”¨è€…è´Ÿè´£åˆ›å»ºå’Œé”€æ¯è¿™ä¸ªçº¿ç¨‹æ± ã€‚
*   **`int qsize`**: å†…éƒ¨ä»»åŠ¡é˜Ÿåˆ—çš„å¤§å°ã€‚å¦‚æœä¼ å…¥0ï¼Œå‡½æ•°ä¼šæ ¹æ®çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡é€‰æ‹©ä¸€ä¸ªåˆç†çš„é»˜è®¤å€¼ï¼ˆé€šå¸¸æ˜¯ `çº¿ç¨‹æ•° * 2`ï¼‰ã€‚

ç„¶ååˆ©ç”¨è¿™ä¸ªAPIç¼–å†™ä»£ç ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å…³é”®å¤´æ–‡ä»¶
#include "htslib/bgzf.h"
#include "htslib/thread_pool.h"

int main() {
    // --- Step 1: åˆ›å»º HTSlib çº¿ç¨‹æ±  ---
    int n_threads = 4;
    hts_tpool *pool = hts_tpool_init(n_threads);
    if (!pool) {
        fprintf(stderr, "Error creating thread pool\n");
        return 1;
    }
    printf("Created a thread pool with %d threads.\n", n_threads);

    // --- Step 2: æ‰“å¼€ BGZF æ–‡ä»¶ ---
    const char *filename = "output.threaded.gz";
    // "w" è¡¨ç¤ºå†™å…¥ï¼Œä¹Ÿå¯ä»¥æ·»åŠ å‹ç¼©çº§åˆ«ï¼Œå¦‚ "w4"
    BGZF *fp = bgzf_open(filename, "w");
    if (fp == NULL) {
        fprintf(stderr, "Could not open %s for writing\n", filename);
        hts_tpool_destroy(pool); // æ¸…ç†çº¿ç¨‹æ± 
        return 1;
    }
    printf("Opened %s for writing.\n", filename);

    // --- Step 3: å…³è”çº¿ç¨‹æ±  ---
    // qsize è®¾ç½®ä¸º 0ï¼Œä½¿ç”¨é»˜è®¤é˜Ÿåˆ—å¤§å°
    if (bgzf_thread_pool(fp, pool, 0) < 0) {
        fprintf(stderr, "Error associating thread pool with BGZF handle\n");
        bgzf_close(fp);
        hts_tpool_destroy(pool);
        return 1;
    }
    printf("Successfully associated thread pool with BGZF file.\n");

    // --- Step 4: æ‰§è¡Œå†™æ“ä½œ (å’Œå•çº¿ç¨‹ä»£ç ä¸€æ ·) ---
    const char *data = "This is a line of text that will be compressed. It will be written many times to create a large file.\n";
    size_t data_len = strlen(data);
    long total_written = 0;
    
    printf("Writing data...\n");
    for (int i = 0; i < 100000; ++i) {
        if (bgzf_write(fp, data, data_len) != data_len) {
            fprintf(stderr, "Error writing to BGZF file\n");
            break;
        }
        total_written += data_len;
    }
    printf("Finished writing. Total uncompressed bytes: %ld\n", total_written);

    // --- Step 5: å…³é—­ BGZF æ–‡ä»¶ ---
    // bgzf_close() ä¼šç­‰å¾…æ‰€æœ‰åå°å‹ç¼©ä»»åŠ¡å®Œæˆ
    printf("Closing BGZF file (this will flush all remaining blocks)...\n");
    if (bgzf_close(fp) < 0) {
        fprintf(stderr, "Error on bgzf_close\n");
    }

    // --- Step 6: é”€æ¯çº¿ç¨‹æ±  ---
    // å¿…é¡»åœ¨ bgzf_close() ä¹‹åè°ƒç”¨
    printf("Destroying thread pool.\n");
    hts_tpool_destroy(pool);

    printf("Done.\n");
    return 0;
}
```

æœ€åæŠŠçº¿ç¨‹æ•°å¼€åˆ°52ï¼›
## CT

### FFTä¼˜åŒ–

ä¸€å¼€å§‹çœ‹åˆ°æœ‰å¾ˆå¤šå·ç§¯æ“ä½œï¼Œç„¶åå¼€å§‹FFTä¼˜åŒ–ï¼›å› ä¸ºæ²¡æ³•è°ƒåº“ï¼Œæ‰€ä»¥åªèƒ½æ‰‹å†™Radix-4 FFTï¼›


```cpp
#include <cmath>
#include <algorithm>
#include <vector>

#include <omp.h>
#include <arm_neon.h>

#include "fbp.h"
#include <complex> // æ–°å¢çš„åŒ…å«ï¼Œç¡®ä¿ std::complex å¯ç”¨

constexpr double PI = 3.14159265358979323846;

/**
 * Generate Ramp filter kernel in spatial domain
 * 
 * @param len  Kernel length (will be made odd if even)
 * @param d    Detector pixel spacing (default 1.0)
 * @return     Symmetric filter kernel centered at middle
 */
static std::vector<float> ramp_kernel(int len, float d = 1.0f) {
    if (len % 2 == 0) len += 1;  // Ensure odd length for symmetry
    int K = len / 2;  // Center index
    
    std::vector<float> h(len, 0.0f);
    
    // Center value
    h[K] = 1.0f / (4.0f * d * d);
    
    // Symmetric side lobes (only odd positions have non-zero values)
    for (int n = 1; n <= K; ++n) {
        if (n % 2 == 1) {
            float val = -1.0f / (float(PI) * float(PI) * n * n * d * d);
            h[K + n] = val;
            h[K - n] = val;
        }
    }
    
    return h;
}

// =================================================================
// FFT-based convolution and related functions
// =================================================================

/**
 * @brief æ‰§è¡Œ in-place Radix-4 å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ (FFT) æˆ–å…¶é€†å˜æ¢ (IFFT)ã€‚
 * 
 * è¯¥å‡½æ•°ä½¿ç”¨ Decimation-In-Time (DIT) Radix-4 ç®—æ³•ã€‚
 * ä¸ºè·å¾—æœ€ä½³æ€§èƒ½ï¼Œè¾“å…¥å‘é‡çš„å¤§å°å¿…é¡»æ˜¯4çš„å¹‚ã€‚
 * 
 * @param data    ä¸€ä¸ªå¤æ•°å‘é‡ã€‚å‡½æ•°å°†ç›´æ¥ä¿®æ”¹æ­¤å‘é‡ã€‚å…¶å¤§å°å¿…é¡»æ˜¯4çš„å¹‚ã€‚
 * @param inverse å¦‚æœä¸º false (é»˜è®¤)ï¼Œåˆ™è®¡ç®—æ­£å‘FFTã€‚
 *                å¦‚æœä¸º trueï¼Œåˆ™è®¡ç®—é€†å‘FFTã€‚
 *                æ³¨æ„ï¼šæ­¤å‡½æ•°ä¸æ‰§è¡Œé€†å˜æ¢åçš„ 1/N ç¼©æ”¾ï¼Œè°ƒç”¨è€…éœ€è¦è‡ªè¡Œå¤„ç†ã€‚
 */
void radix4_fft(std::vector<std::complex<float>>& data, bool inverse = false) {
    const size_t N = data.size();

    // --- 1. è¾“å…¥éªŒè¯ ---
    if (N == 0) {
        return;
    }

    // æ£€æŸ¥Næ˜¯å¦ä¸º4çš„å¹‚ (å¦‚æœè¾“å…¥ä¿è¯æ­£ç¡®å¯ä»¥æ³¨é‡Šæ‰ä»¥æå‡æ€§èƒ½)
    // size_t temp_check = N;
    // if ((N & (N - 1)) != 0 && N != 1) { // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æ˜¯2çš„å¹‚
    //     throw std::invalid_argument("Vector size for Radix-4 FFT must be a power of 4.");
    // }
    // while (temp_check > 1) {
    //     if (temp_check % 4 != 0) {
    //         throw std::invalid_argument("Vector size for Radix-4 FFT must be a power of 4.");
    //     }
    //     temp_check /= 4;
    // }


    // --- 2. 4åŸºä½åè½¬ (Radix-4 Bit-Reversal Permutation) ---
    // è¿™ä¸ªæ­¥éª¤å°†æ•°æ®é‡æ–°æ’åºï¼Œä»¥ä¾¿è¶å½¢è¿ç®—å¯ä»¥å°±åœ°æ‰§è¡Œã€‚
    // j æ˜¯ i çš„4åŸºåè½¬åçš„ç´¢å¼•ã€‚
    size_t j = 0;
    for (size_t i = 1; i < N; ++i) {
        size_t k = N / 4;
        while (j >= 3 * k) {
            j -= 3 * k;
            k /= 4;
        }
        j += k;

        if (i < j) {
            std::swap(data[i], data[j]);
        }
    }

    // --- 3. è¶å½¢è¿ç®— (Butterfly Operations) ---
    // ç¡®å®šæ—‹è½¬å› å­çš„è§’åº¦ç¬¦å·
    const float angle_sign = inverse ? 1.0f : -1.0f;
    const std::complex<float> j_factor(0, angle_sign); // ä»£è¡¨ -j (æ­£å‘) æˆ– +j (é€†å‘)

    // é€çº§è®¡ç®—DFTï¼Œä»å¤§å°ä¸º4çš„DFTå¼€å§‹ï¼Œç›´åˆ°å¤§å°ä¸ºN
    for (size_t m = 4; m <= N; m *= 4) {
        const float angle_base = angle_sign * 2.0f * static_cast<float>(PI) / m;
        
        // éå†æ¯ä¸ªDFTå—
        for (size_t i = 0; i < N; i += m) {
            // éå†æ¯ä¸ªå—å†…çš„è¶å½¢è¿ç®—
            for (size_t k = 0; k < m / 4; ++k) {
                // --- è®¡ç®—æ—‹è½¬å› å­ (Twiddle Factors) ---
                // W_m^k, W_m^(2k), W_m^(3k)
                auto w1 = std::polar(1.0f, angle_base * k);
                auto w2 = std::polar(1.0f, angle_base * (2 * k));
                auto w3 = std::polar(1.0f, angle_base * (3 * k));

                // --- Radix-4 è¶å½¢è¿ç®— ---
                // ä»å‘é‡ä¸­å–å‡º4ä¸ªç‚¹
                const size_t idx0 = i + k;
                const size_t idx1 = i + k + m / 4;
                const size_t idx2 = i + k + m / 2;
                const size_t idx3 = i + k + 3 * m / 4;

                auto c0 = data[idx0];
                auto c1 = data[idx1];
                auto c2 = data[idx2];
                auto c3 = data[idx3];

                // å…ˆå°†åä¸‰ä¸ªç‚¹ä¹˜ä»¥æ—‹è½¬å› å­
                auto p1 = c1 * w1;
                auto p2 = c2 * w2;
                auto p3 = c3 * w3;
                
                // æ‰§è¡Œé«˜æ•ˆçš„4ç‚¹DFTè®¡ç®—
                auto q1 = c0 + p2;
                auto q2 = c0 - p2;
                auto q3 = p1 + p3;
                auto q4 = (p1 - p3) * j_factor;

                // å°†ç»“æœå­˜å›åŸä½
                data[idx0] = q1 + q3;
                data[idx1] = q2 + q4;
                data[idx2] = q1 - q3;
                data[idx3] = q2 - q4;
            }
        }
    }
}

/**
 * Apply Ramp filter to all projections in a sinogram (in-place convolution) using FFT.
 * 
 * @param sino        Sinogram data [n_total_angles, n_det] - modified in-place
 * @param n_total_angles Total number of projections to filter (e.g., n_slices * n_angles)
 * @param n_det       Number of detector pixels
 * @param fft_kernel  Pre-computed FFT of the Ramp filter kernel
 */
static void filter_projections_fft(
    float* sino, 
    int n_total_angles, 
    int n_det, 
    const std::vector<std::complex<float>>& fft_kernel // é¢„è®¡ç®—å¥½çš„
) {
    int fft_len = fft_kernel.size();
	std::vector<std::complex<float>> proj_padded(fft_len);
	for (int a = 0; a < n_total_angles; ++a) {
		float* row = &sino[a * n_det];

		// 1. å¡«å……æ•°æ®
		for (int i = 0; i < n_det; ++i) {
			proj_padded[i] = {row[i], 0.0f};
		}
		std::fill(proj_padded.begin() + n_det, proj_padded.end(), 0.0f);

		// 2. æ­£å‘FFT
		radix4_fft(proj_padded, false); // <--- MODIFIED: Corrected function name

		// 3. é¢‘åŸŸä¹˜ç§¯ (Hadamard product)
		for (int i = 0; i < fft_len; ++i) {
			proj_padded[i] *= fft_kernel[i];
		}

		// 4. é€†å‘FFT
		radix4_fft(proj_padded, true); // <--- MODIFIED: Corrected function name

		// 5. å†™å›ç»“æœ (æ³¨æ„å½’ä¸€åŒ–)
		float scale = 1.0f / fft_len;
		for (int i = 0; i < n_det; ++i) {
			row[i] = proj_padded[i].real() * scale;
		}
	}
}


// This is the original direct convolution function, kept here for reference or testing.
static void filter_projections(float* sino, int n_angles, int n_det, const std::vector<float>& kernel) {
    int K = int(kernel.size() / 2);

    std::vector<float> tmp(n_det);
    
    for (int a = 0; a < n_angles; ++a) {
        float* row = &sino[a * n_det];
        
        // 1D Convolution: filtered[x] = sum(row[x+k] * kernel[K+k])
        for (int x = 0; x < n_det; ++x) {
            float acc = 0.0f;
            
            // Only convolve within valid detector range
            int k_start = std::max(-K, -x);
            int k_end = std::min(K, n_det - 1 - x);
            
            for (int k = k_start; k <= k_end; ++k) {
                acc += row[x + k] * kernel[K + k];
            }
            
            tmp[x] = acc;
        }
        
        // Write filtered values back to input array
        for (int x = 0; x < n_det; ++x) {
            row[x] = tmp[x];
        }
    }
}

void fbp_reconstruct_3d(
    float* sino_buffer,
    float* recon_buffer,
    int n_slices,
    int n_angles,
    int n_det,
    const std::vector<float>& angles_deg
) {
    size_t slice_size = size_t(n_angles) * n_det;
    size_t recon_size = size_t(n_det) * n_det;
    
    // ============================================================
    // STEP 0: Precomputation
    // ============================================================
    
    // Compute ramp filter kernel once (shared by all slices)
    auto kernel_spatial = ramp_kernel(n_det | 1);

    // ============================================================
    // NEW: Prepare the FFT of the Kernel
    // This is done only ONCE for all slices and projections.
    // ============================================================
    
    // 1. Determine the FFT length. It must be a power of 4 and large enough for linear convolution.
    int min_len = n_det + kernel_spatial.size() - 1;
    int fft_len = 1;
    if (min_len > 1) {
        // A simple loop to find the next power of 4
        while (fft_len < min_len) {
            fft_len *= 4;
        }
    }
    
    // 2. Create a complex vector for the kernel, zero-pad it, and align its center.
    std::vector<std::complex<float>> fft_kernel(fft_len, {0.0f, 0.0f});
    int K = kernel_spatial.size() / 2; // Center index of the spatial kernel

    // The center of the spatial kernel (at index K) goes to the beginning of the padded vector (index 0).
    fft_kernel[0] = {kernel_spatial[K], 0.0f};
    
    // The right part of the kernel (from K+1 to end) goes to the start of the vector.
    for (int i = 1; i <= K; ++i) {
        fft_kernel[i] = {kernel_spatial[K + i], 0.0f};
    }
    // The left part of the kernel (from 0 to K-1) is wrapped around to the end of the vector.
    for (int i = 1; i <= K; ++i) {
        fft_kernel[fft_len - i] = {kernel_spatial[K - i], 0.0f};
    }

    // 3. Perform FFT on the padded and shifted kernel to get the frequency-domain filter.
    radix4_fft(fft_kernel, false);


    // Precompute trigonometric values for all projection angles
    std::vector<float> cos_theta(n_angles);
    std::vector<float> sin_theta(n_angles);
    const float deg2rad = float(PI) / 180.0f;
    
    for (int ai = 0; ai < n_angles; ++ai) {
        float th = angles_deg[ai] * deg2rad;
        cos_theta[ai] = std::cos(th);
        sin_theta[ai] = std::sin(th);
    }
    
    // Image geometry parameters
    const float cx = (n_det - 1) * 0.5f;      // Image center X
    const float cy = (n_det - 1) * 0.5f;      // Image center Y
    const float t_half = (n_det - 1) * 0.5f;  // Detector offset to center
    const float scale = float(PI) / float(n_angles);  // Normalization factor from Radon inversion
    
    // ============================================================
    // STEP 1: Filter all projections (Ramp filtering)
    // ============================================================
    // We call the new FFT-based filter function.
    // The OpenMP parallelization is now inside filter_projections_fft.
    // We pass the entire buffer and the total number of projections.
    filter_projections_fft(sino_buffer, n_slices * n_angles, n_det, fft_kernel);
    
    // ============================================================
    // STEP 2: Backprojection
    // ============================================================
    #pragma omp parallel for
    for (int slice_id = 0; slice_id < n_slices; ++slice_id) {
        // Pointers to input (filtered sinogram) and output (reconstructed image)
        const float* sino_slice = sino_buffer + slice_id * slice_size;
        float* recon_slice = recon_buffer + slice_id * recon_size;
        
        // For each pixel in the reconstructed image
        for (int y = 0; y < n_det; ++y) {
            float yr = y - cy;  // Y coordinate relative to image center
            float* recon_row = recon_slice + y * n_det;
            
            for (int x = 0; x < n_det; ++x) {
                float xr = x - cx;  // X coordinate relative to image center
                float acc = 0.0f;
                
                // Accumulate contributions from all projection angles
                for (int ai = 0; ai < n_angles; ++ai) {
                    float c = cos_theta[ai];
                    float s = sin_theta[ai];
                    
                    // Radon transform: t = x*cos(Î¸) + y*sin(Î¸)
                    // This is the position where pixel (x,y) projects onto detector at angle Î¸
                    float t = xr * c + yr * s;
                    
                    // Convert to detector coordinate (0 to n_det-1)
                    float u = t + t_half;
                    
                    // Integer and fractional parts for interpolation
                    int u0 = int(u);
                    float du = u - u0;
                    int u1 = u0 + 1;
                    
                    // Bilinear interpolation between adjacent detector pixels
                    float w0 = (u0 >= 0 && u0 < n_det) ? (1.0f - du) : 0.0f;
                    float w1 = (u1 >= 0 && u1 < n_det) ? du : 0.0f;
                    
                    // Read filtered projection values
                    const float* sino_row = sino_slice + ai * n_det;
                    float v0 = (u0 >= 0 && u0 < n_det) ? sino_row[u0] : 0.0f;
                    float v1 = (u1 >= 0 && u1 < n_det) ? sino_row[u1] : 0.0f;
                    
                    // Accumulate interpolated value
                    acc += w0 * v0 + w1 * v1;
                }
                
                // Apply normalization factor (Ï€ / N_angles from Radon inverse formula)
                recon_row[x] = acc * scale;
            }
        }

    }
}
```

ä½†æ˜¯æŠŠè¿™ä¸ªä»£ç æ”¾åˆ°OJä¸Šè·‘ï¼Œæ­£ç¡®ç‡ä¸é€šè¿‡ï¼Œè€Œä¸”æ€§èƒ½å·®åˆ«å¾®ä¹å…¶å¾®ã€‚æ­£ç¡®ç‡ä¸Šå®åœ¨ä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œæ€§èƒ½ä¸Šå‘ç°FFTåªèƒ½æ”¹å˜æ»¤æ³¢çš„æ•ˆç‡ï¼Œä½†æ˜¯ä¸»è¦çš„æ€§èƒ½ç“¶é¢ˆåœ¨Backprojection.

### OpenMP ä¼˜åŒ–

å°è¯•åŠ äº†å‡ ä¸ªOpenMPï¼Œç„¶åæ€§èƒ½è¿…é€Ÿæä¸Šæ¥äº†[ac01] ï¼Œå…·ä½“è§ã€Šå¹¶è¡Œè®¡ç®—å¯¼è®ºã€‹å’Œæœ€ç»ˆä»£ç ï¼›

### SIMDä¼˜åŒ–

å› ä¸ºå¼•ç”¨äº†å¤´æ–‡ä»¶`<arm_neon.h>`ï¼Œæ‰€ä»¥ä½¿ç”¨AVX-512åŠ é€Ÿï¼Œä¸»è¦å°±æ˜¯é‡å†™æŒ‡ä»¤ï¼›

### è®¿å­˜ä¼˜åŒ–

ä½†æ˜¯OpenMPæœ‰å†…å­˜å†™ç«äº‰å¾ˆä¸¥é‡ã€‚

- `#pragma omp parallel for`ç”¨åœ¨äº†æœ€å¤–å±‚çš„slice_idå¾ªç¯ä¸Šã€‚è¿™æœ¬èº«æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç²—ç²’åº¦å¹¶è¡Œç­–ç•¥ã€‚

- ç”±äºå…¶å†…éƒ¨ç®—æ³•å­˜åœ¨ä¸¥é‡çš„å†…å­˜å†™ç«äº‰ï¼Œè¿™ç§å¹¶è¡Œç­–ç•¥åè€Œæ”¾å¤§äº†é—®é¢˜ã€‚çº¿ç¨‹æ•°è¶Šå¤šï¼Œç«äº‰å¯èƒ½è¶Šæ¿€çƒˆï¼Œæ€§èƒ½ç”šè‡³å¯èƒ½ä¸å‡åé™ã€‚

ä¸€å¼€å§‹ä»¥aiå’Œu_idxä¸ºå¤–å±‚å¾ªç¯çš„ç»“æ„é‡æ„äº†ä»£ç ï¼Œè¿™æ ·å†…å­˜è¯»å°±æ˜¯è¿ç»­çš„ï¼Œç»“æœæ€§èƒ½ä¸å¦‚ä»¥å›¾åƒåƒç´ åæ ‡yå’Œxä¸ºæœ€å¤–å±‚å¾ªç¯

åæ¥å‘ç°æ˜¯ **å†…å­˜å†™ä¸è¿ç»­çš„å½±å“å¤§äºå†…å­˜è¯»ä¸è¿ç»­**

> å¯¹å†…å­˜ï¼ŒCacheå‘½ä¸­ï¼Œæ€§èƒ½è¿™äº›çš„æ¦‚å¿µäº†è§£å¤ªå°‘äº†

## Conway Game of Life

### C++ é‡æ„

pythonçš„è¿è¡Œé€Ÿåº¦æ˜¾è‘—æ…¢äºC++ï¼Œæ‰€ä»¥ç”¨C++é‡æ„è¿™ä¸ªå‡½æ•°æ¥é™ä½é€šä¿¡çš„æ—¶é—´æˆæœ¬ï¼›

### uvä½¿ç”¨

è¿™é“é¢˜è¦ç”¨åˆ°pythonï¼Œæ‰€ä»¥ä½¿ç”¨äº†uv.

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

å®‰è£…åé‡å¯Shell

```bash
exec $SHELL
```

```bash
uv --version
```

ç„¶åè¿›å…¥é¡¹ç›®æ–‡ä»¶å¤¹

```bash
uv venv
source .venv/bin/activate # æ¿€æ´»
```

å®‰è£…

```bash
# å®‰è£…å•ä¸ªåŒ… 
uv pip install requests 
# åŒæ—¶å®‰è£…å¤šä¸ªåŒ… 
uv pip install numpy pandas matplotlib 
# ä» requirements.txt æ–‡ä»¶å®‰è£… 
uv pip install -r requirements.txt
```

ç¼–è¯‘ä¸€ä¸ªcppæ¨¡å—ï¼Œè®©ä»–å˜æˆpythonå¯ä»¥importçš„æ¨¡å—

```bash
python setup.py build_ext --inplace
```

### å‘é‡åŒ–

è§ä»£ç ï¼›

### åˆ†å—

å¥½åƒæ˜¯è¿™ä¸€é¢˜å†™äº†ï¼Œä½†æ˜¯å®Œå…¨æ²¡çœ‹æ‡‚ï¼Œå®Œå…¨æ˜¯AIå†™çš„
### TD

ä½¿ç”¨ä½å‹ç¼© (Bit-packing)çš„æ–¹æ³•æ¥ä¼˜åŒ–

å¤§è‡´æ€è·¯ï¼š
ä¼˜åŒ–å»ºè®®
A. ä½å‹ç¼© (Bit-packing)
è¿™æ˜¯ä¸€ä¸ªé«˜çº§æŠ€å·§ï¼Œä½†æ•ˆæœæ‹”ç¾¤ã€‚ç”±äºæ¯ä¸ªç»†èƒåªæœ‰æ­»/æ´»ä¸¤ç§çŠ¶æ€ï¼Œä½¿ç”¨uint8_t (8ä½) æ¥å­˜å‚¨æ˜¯æµªè´¹çš„ã€‚å¯ä»¥ç”¨1ä¸ªæ¯”ç‰¹ä½æ¥ä»£è¡¨ä¸€ä¸ªç»†èƒã€‚
æ•°æ®ç»“æ„ï¼šä¸€ä¸ªuint64_tçš„æ•°ç»„å¯ä»¥ç”¨æ¥å­˜å‚¨ç½‘æ ¼ï¼Œæ¯ä¸ªuint64_tå¯ä»¥å­˜æ”¾64ä¸ªç»†èƒçš„çŠ¶æ€ã€‚
è®¡ç®—ï¼šé‚»å±…æ•°é‡çš„è®¡ç®—å¯ä»¥é€šè¿‡ä½ç§»ï¼ˆ>>, <<ï¼‰å’Œä½è¿ç®—ï¼ˆ&, |, ^ï¼‰åœ¨64ä¸ªç»†èƒä¸Šå¹¶è¡Œå®Œæˆã€‚
ä¾‹å¦‚ï¼Œè®¡ç®—ä¸€æ’64ä¸ªç»†èƒçš„ä¸Šæ–¹é‚»å±…ä¹‹å’Œï¼Œå¯ä»¥è¿™æ ·åšï¼š

```cpp
uint64_t row_above = ...;
uint64_t n1 = (row_above << 1) | (/* å·¦è¾¹ä¸€ä¸ªå•å…ƒçš„æ•°æ® */);
uint64_t n2 = row_above;
uint64_t n3 = (row_above >> 1) | (/* å³è¾¹ä¸€ä¸ªå•å…ƒçš„æ•°æ® */);
// ... å¯¹ä¸­é—´è¡Œå’Œä¸‹é¢è¡Œä¹Ÿè¿™æ ·åš ...
```
**ä¼˜ç‚¹**ï¼š
*   **å†…å­˜å ç”¨å‡å°‘8å€**ï¼šæå¤§åœ°æé«˜äº†ç¼“å­˜å‘½ä¸­ç‡å’Œå†…å­˜å¸¦å®½åˆ©ç”¨ç‡ã€‚
*   **è®¡ç®—æ•ˆç‡æé«˜**ï¼šä½è¿ç®—æ˜¯CPUæœ€å¿«çš„æ“ä½œä¹‹ä¸€ã€‚

**ç¼ºç‚¹**ï¼š
*   å®ç°éå¸¸å¤æ‚ï¼Œå°¤å…¶æ˜¯å¤„ç†è¾¹ç•Œæƒ…å†µã€‚


```cpp
#include <vector>
#include <tuple>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <iostream>
#include <algorithm>
#include <omp.h>
#include <arm_neon.h>

namespace py = pybind11;

class Grid {
public:

    int height;
    int width;
    std::vector<uint8_t> data;
    // é»˜è®¤æ„é€ å‡½æ•°
    Grid() : height(0), width(0) {}

    // æ„é€ å‡½æ•°ï¼Œåˆ›å»ºæŒ‡å®šå¤§å°å¹¶ç”¨0å¡«å……çš„ç½‘æ ¼
    Grid(int h, int w) : height(h), width(w), data(h * w, 0) {}

    // (å…³é”®) ä» pybind11 è½¬æ¢è¿‡æ¥çš„ vector<vector> æ„é€ ç½‘æ ¼
    Grid(const std::vector<std::vector<uint8_t>>& vec_2d) {
        if (vec_2d.empty() || vec_2d[0].empty()) {
            height = 0;
            width = 0;
            return;
        }
        height = vec_2d.size();
        width = vec_2d[0].size();
        data.resize(height * width);
        for (int y = 0; y < height; ++y) {
            std::copy(vec_2d[y].begin(), vec_2d[y].end(), data.begin() + y * width);
        }
    }

    // (å…³é”®) äºŒç»´è®¿é—®å‡½æ•° (operator overloading)
    // è¿™æ˜¯è®© grid(y, x) è¯­æ³•ç”Ÿæ•ˆçš„æ ¸å¿ƒ
    uint8_t& operator()(int y, int x) {
        return data[y * width + x];
    }
    const uint8_t& operator()(int y, int x) const {
        return data[y * width + x];
    }
    
    // (å…³é”®) å°†æ‰å¹³åŒ–çš„Gridè½¬æ¢å› pybind11 èƒ½è¯†åˆ«çš„ vector<vector>
    std::vector<std::vector<uint8_t>> to_vector_2d() const {
        if (empty()) {
            return {};
        }
        std::vector<std::vector<uint8_t>> vec_2d(height, std::vector<uint8_t>(width));
        for (int y = 0; y < height; ++y) {
            std::copy(data.begin() + y * width, data.begin() + (y + 1) * width, vec_2d[y].begin());
        }
        return vec_2d;
    }

    // è¾…åŠ©å‡½æ•°
    bool empty() const { return height == 0 || width == 0; }
    
    // ä¸º expand_cpp ä¸­çš„æ¯”è¾ƒæä¾›æ”¯æŒ
    bool operator==(const Grid& other) const {
        return height == other.height && width == other.width && data == other.data;
    }
};

// è¾…åŠ©å‡½æ•°ï¼šä½¿ç”¨æ ‡é‡ï¼ˆéNEONï¼‰æ–¹å¼è®¡ç®—å•ä¸ªç»†èƒçš„ä¸‹ä¸€çŠ¶æ€
// è¿™ä¸ªå‡½æ•°ä¼šå¤„ç†è¾¹ç•Œæ£€æŸ¥ï¼Œå› æ­¤å¯ä»¥å®‰å…¨åœ°ç”¨äºä»»ä½•åæ ‡
void scalar_calculate_cell(const Grid& p_grid, Grid& next_p_grid, int y, int x) {
    int height = p_grid.height;
    int width = p_grid.width;
    int live_neighbors = 0;

    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            if (i == 0 && j == 0) continue;
            int ny = y + i;
            int nx = x + j;
            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                live_neighbors += p_grid(ny, nx);
            }
        }
    }

    if (p_grid(y, x) == 1) {
        next_p_grid(y, x) = (live_neighbors == 2 || live_neighbors == 3);
    } else {
        next_p_grid(y, x) = (live_neighbors == 3);
    }
}


std::pair<Grid, std::pair<int, int>> Next_Generation_Cpp(const Grid& current_grid) {
    if (current_grid.empty()) {
        return {Grid(), {0, 0}};
    }

    int height = current_grid.height;
    int width = current_grid.width;
    int padded_height = height + 2;
    int padded_width = width + 2;

    Grid padded_grid(padded_height, padded_width);
    for (int i = 0; i < height; ++i) {
        std::copy(&current_grid(i, 0), &current_grid(i, 0) + width, &padded_grid(i + 1, 1));
    }

    Grid next_padded_grid(padded_height, padded_width);

    #pragma omp parallel for
    for (int y = 0; y < padded_height; ++y) {
        // å¯¹äºé¡¶éƒ¨å’Œåº•éƒ¨è¾¹ç•Œè¡Œ (y=0 å’Œ y=height+1)ï¼Œæˆ–è€…å½“å®½åº¦ä¸è¶³ä»¥ä½¿ç”¨NEONæ—¶ï¼Œå®Œå…¨ä½¿ç”¨æ ‡é‡è®¡ç®—
        if (y == 0 || y == padded_height - 1 || width < 16) {
            for (int x = 0; x < padded_width; ++x) {
                scalar_calculate_cell(padded_grid, next_padded_grid, y, x);
            }
            continue; // å¤„ç†å®Œæ­¤è¡Œï¼Œè¿›å…¥ä¸‹ä¸€è½®yå¾ªç¯
        }

        // --- å¯¹äºå†…éƒ¨è¡Œ (y=1 to height) ---
        // 1. å¤„ç†å·¦è¾¹ç•Œ (x=0)
        scalar_calculate_cell(padded_grid, next_padded_grid, y, 0);

        // 2. ä½¿ç”¨ NEON å¤„ç†ä¸­é—´éƒ¨åˆ†
        // #if defined(__aarch64__)
        int x = 1;
        for (; x <= width - 15; x += 16) {
            uint8_t* row_above = &padded_grid(y - 1, 0);
            uint8_t* row_curr = &padded_grid(y, 0);
            uint8_t* row_below = &padded_grid(y + 1, 0);

            uint8x16_t top_left = vld1q_u8(&row_above[x - 1]);
            uint8x16_t top_mid = vld1q_u8(&row_above[x]);
            uint8x16_t top_right = vld1q_u8(&row_above[x + 1]);
            uint8x16_t mid_left = vld1q_u8(&row_curr[x - 1]);
            uint8x16_t mid_right = vld1q_u8(&row_curr[x + 1]);
            uint8x16_t bot_left = vld1q_u8(&row_below[x - 1]);
            uint8x16_t bot_mid = vld1q_u8(&row_below[x]);
            uint8x16_t bot_right = vld1q_u8(&row_below[x + 1]);

            uint8x16_t neighbors = vaddq_u8(top_left, top_mid);
            neighbors = vaddq_u8(neighbors, top_right);
            neighbors = vaddq_u8(neighbors, mid_left);
            neighbors = vaddq_u8(neighbors, mid_right);
            neighbors = vaddq_u8(neighbors, bot_left);
            neighbors = vaddq_u8(neighbors, bot_mid);
            neighbors = vaddq_u8(neighbors, bot_right);

            uint8x16_t current_cells = vld1q_u8(&row_curr[x]);
            const uint8x16_t const_2 = vdupq_n_u8(2);
            const uint8x16_t const_3 = vdupq_n_u8(3);
            uint8x16_t is_3_neighbors = vceqq_u8(neighbors, const_3);
            uint8x16_t is_2_neighbors = vceqq_u8(neighbors, const_2);
            const uint8x16_t const_1 = vdupq_n_u8(1);
            uint8x16_t is_alive_mask = vceqq_u8(current_cells, const_1);
            uint8x16_t alive_and_2_neighbors = vandq_u8(is_alive_mask, is_2_neighbors);
            uint8x16_t next_state_mask = vorrq_u8(is_3_neighbors, alive_and_2_neighbors);
            uint8x16_t next_state = vshrq_n_u8(next_state_mask, 7);

            vst1q_u8(&next_padded_grid(y, x), next_state);
        }
        //#else
        //int x = 1; // å¦‚æœä¸æ˜¯ aarch64ï¼Œåˆ™ x ä» 1 å¼€å§‹
        //#endif

        // 3. å¤„ç† NEON æœªè¦†ç›–çš„å‰©ä½™éƒ¨åˆ†å’Œå³è¾¹ç•Œ
        for (; x < padded_width; ++x) {
            scalar_calculate_cell(padded_grid, next_padded_grid, y, x);
        }
    }

    // --- è£å‰ªç½‘æ ¼ (Cropping Logic) ---
    // è¿™éƒ¨åˆ†é€»è¾‘æ— éœ€ä¿®æ”¹ï¼Œä½†è¦ç¡®ä¿å®ƒåœ¨ä¸²è¡Œæ¨¡å¼ä¸‹è¿è¡Œä»¥é¿å…æ•°æ®äº‰ç”¨
    int min_y = padded_height, max_y = -1;
    int min_x = padded_width, max_x = -1;

    for (int y = 0; y < padded_height; ++y) {
        for (int x = 0; x < padded_width; ++x) {
            if (next_padded_grid(y, x) == 1) {
                if (y < min_y) min_y = y;
                if (y > max_y) max_y = y;
                if (x < min_x) min_x = x;
                if (x > max_x) max_x = x;
            }
        }
    }

    if (max_y == -1) {
        return {Grid(), {0, 0}};
    }

    // ä¿®æ”¹ï¼šè£å‰ªé€»è¾‘
    int final_height = max_y - min_y + 1;
    int final_width = max_x - min_x + 1;
    Grid final_grid(final_height, final_width);
    for (int y = 0; y < final_height; ++y) {
        const uint8_t* src_row_start = &next_padded_grid(min_y + y, min_x);
        uint8_t* dst_row_start = &final_grid(y, 0);
        std::copy(src_row_start, src_row_start + final_width, dst_row_start);
    }
    
    std::pair<int, int> offset = {min_y - 1, min_x - 1};
    return {final_grid, offset};
}

Grid expand_cpp(const Grid& initial_grid, int iter) {
    Grid grid = initial_grid; // åˆ›å»ºä¸€ä¸ªå¯ä¿®æ”¹çš„å‰¯æœ¬
    for (int i = 0; i < iter; ++i) {
        if (grid.empty()) {
            break;
        }
        Grid prev_grid = grid;
        auto result = Next_Generation_Cpp(grid);
        grid = result.first;
        if (grid == prev_grid) { // operator== ç°åœ¨ç”±Gridç±»æä¾›
            break;
        }
    }
    return grid;
}

PYBIND11_MODULE(NG, m) {
    m.def("Expand", 
          [](const std::vector<std::vector<uint8_t>>& initial_grid_vec, int generations) {
              Grid initial_grid(initial_grid_vec); // è‡ªåŠ¨ä» vector<vector> æ„é€ 
              Grid final_grid = expand_cpp(initial_grid, generations);
              return final_grid.to_vector_2d(); // å°†ç»“æœè½¬æ¢å› vector<vector>
          },
          "Simulate multiple generations of Conway's Game of Life and return the final state",
          py::arg("initial_grid"), py::arg("generations"));

    m.def("Next_Generation_Cpp", 
          [](const std::vector<std::vector<uint8_t>>& grid_vec) {
              Grid grid(grid_vec); // è‡ªåŠ¨ä» vector<vector> æ„é€ 
              auto [final_grid, offset] = Next_Generation_Cpp(grid);
              // è¿”å› pair<vector<vector>, pair<int, int>>
              return std::make_pair(final_grid.to_vector_2d(), offset);
          },
          "Calculates one generation and returns grid and offset for visualization",
          py::arg("grid"));
}
```
## SPMM

### 1. è®¿å­˜ä¼˜åŒ–ï¼šä¿®æ”¹å¾ªç¯ç»“æ„

- æé«˜ç¼“å­˜å‘½ä¸­ç‡
for m -> for i -> for jÂ çš„å¾ªç¯é¡ºåºè¢«ä¿ç•™äº†ä¸‹æ¥ï¼Œè¿™ç¡®ä¿äº†åœ¨æœ€å†…å±‚çš„Â jÂ å¾ªç¯ä¸­ï¼Œå¯¹Â vinÂ å’ŒÂ voutÂ çš„è®¿é—®éƒ½æ˜¯è¿ç»­çš„ã€‚
### 2. SIMDå‘é‡åŒ– / OpenMP

```cpp
#include "spmm_opt.h"

#include <cstdlib>

#include <cstring>

#include <omp.h>

#include <arm_neon.h>

  

void spmm_cpu_opt(const int* __restrict__ ptr, const int* __restrict__ idx, const float* __restrict__ val, const float* __restrict__ vin, float* __restrict__ vout, const int num_v, const int INFEATURE, const int k)

{

Â  Â  // å…¨å±€æ¸…é›¶

Â  Â  memset(vout, 0, sizeof(float) * num_v * INFEATURE);

  

Â  Â  // é€‰æ‹©ä¸€ç§è°ƒåº¦ç­–ç•¥è¿›è¡Œæµ‹è¯•ï¼Œä¾‹å¦‚ dynamic

Â  Â  #pragma omp parallel for schedule(dynamic, 8)

Â  Â  for (int m = 0; m < num_v; ++m) {

Â  Â  Â  Â  const int begin = ptr[m];

Â  Â  Â  Â  const int end = ptr[m + 1];

  

Â  Â  Â  Â  // éå†è¯¥è¡Œçš„æ‰€æœ‰éé›¶å…ƒç´ 

Â  Â  Â  Â  for (int i = begin; i < end; ++i) {

Â  Â  Â  Â  Â  Â  const int col_idx = idx[i];

Â  Â  Â  Â  Â  Â  const float scalar_val = val[i];

Â  Â  Â  Â  Â  Â  // å°†æ ‡é‡å€¼å¹¿æ’­åˆ°NEONå‘é‡

Â  Â  Â  Â  Â  Â  const float32x4_t scalar_vec = vdupq_n_f32(scalar_val);

  

Â  Â  Â  Â  Â  Â  // å‘é‡åŒ–ä¸»å¾ªç¯

Â  Â  Â  Â  Â  Â  int j = 0;

Â  Â  Â  Â  Â  Â  for (; j + 3 < INFEATURE; j += 4) {

Â  Â  Â  Â  Â  Â  Â  Â  const float32x4_t vin_vec = vld1q_f32(&vin[col_idx * INFEATURE + j]);

Â  Â  Â  Â  Â  Â  Â  Â  float32x4_t vout_vec = vld1q_f32(&vout[m * INFEATURE + j]);

Â  Â  Â  Â  Â  Â  Â  Â  vout_vec = vfmaq_f32(vout_vec, vin_vec, scalar_vec);

Â  Â  Â  Â  Â  Â  Â  Â  vst1q_f32(&vout[m * INFEATURE + j], vout_vec);

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  // å¤„ç†å°¾éƒ¨æ•°æ®

Â  Â  Â  Â  Â  Â  for (; j < INFEATURE; ++j) {

Â  Â  Â  Â  Â  Â  Â  Â  vout[m * INFEATURE + j] += vin[col_idx * INFEATURE + j] * scalar_val;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  }

}
```

å®é™…ä¸Šè¿™ä¸€é¢˜çš„æ€§èƒ½åˆ†å·²ç»600å¤šåˆ†äº†ï¼Œä½†æ˜¯å¤§å®¶çš„ä¼˜åŒ–æ•ˆæœéƒ½å¤ªå¥½äº†orz

> åç»­å¯ä»¥åšçš„ä¼˜åŒ–ï¼šæˆ‘æƒ³å¯¹denseçŸ©é˜µv_inè¿›è¡Œåˆ†å—ï¼Œå’Œç¨€ç–çŸ©é˜µè¿›è¡ŒåŸå…ˆçš„ä¹˜æ³•æ“ä½œï¼Œæœ€åå°†ä»–ä»¬çš„ç»“æœæ•´åˆèµ·æ¥
## rvLLM

### RVVå‘é‡ä¼˜åŒ–

ä»‹ç»ä¸»è¦çœ‹è¿™é‡Œï¼Œç„¶åSpaceMiTä»£ç æˆ‘å°è¯•å†™äº†å‘ç°æ¶æ„ä¸æ”¯æŒ ac01

[Lab 2.5: å‘é‡åŒ–è¿›é˜¶ (RISC-V) - HPC101 (2025)](https://hpc101.zjusct.io/lab/Lab2.5-RISC-V/)

å…ˆè®©AIå†™äº†ä¸€ç‰ˆï¼Œä½†æ˜¯æŒ‡ä»¤æ˜¯å…¨é”™çš„ï¼ŒåŸºæœ¬ç”¨Intrinsic Vieweræ¥æŸ¥

https://dzaima.github.io/intrinsics-viewer/#riscv

```cpp
void rvllm_vec_dot_q4_0_q8_0(int n, float * restrict result, size_t byte_stride_result, const void * restrict vec_x, size_t byte_stride_vec_x, const void * restrict vec_y, size_t byte_stride_vec_y, int num_rows_per_vec_dot){

Â  Â  const int BLOCK_SIZE = QK8_0;

Â  Â  const int num_blocks = n / BLOCK_SIZE;

  

Â  Â  UNUSED(byte_stride_result);

Â  Â  UNUSED(byte_stride_vec_x);

Â  Â  UNUSED(byte_stride_vec_y);

Â  Â  UNUSED(num_rows_per_vec_dot);

  

Â  Â  const block_q4_0 * restrict x = vec_x;

Â  Â  const block_q8_0 * restrict y = vec_y;

  

Â  Â  // --- æ€§èƒ½åˆ†æ: æ„å»ºæ—¥å¿—æ–‡ä»¶è·¯å¾„å¹¶åœ¨å¾ªç¯å¤–æ‰“å¼€ ---

Â  Â  char rvllm_log_path[256];

Â  Â  snprintf(rvllm_log_path, sizeof(rvllm_log_path), "%s/rvllm_perf.txt", output_dir);

Â  Â  FILE * f_rvllm = fopen(rvllm_log_path, "w");

Â  Â  if (!f_rvllm) {

Â  Â  Â  Â  perror("Failed to open rvllm_perf.txt");

Â  Â  }

  

Â  Â  unsigned long long ov_ticks = 0;

Â  Â  {

Â  Â  Â  Â  unsigned long long s1 = read_time_ticks();

Â  Â  Â  Â  for (volatile int t=0; t<10; ++t) asm volatile("" ::: "memory");

Â  Â  Â  Â  unsigned long long e1 = read_time_ticks();

Â  Â  Â  Â  ov_ticks = e1 - s1;

Â  Â  }

  

Â  Â  float res = 0.0;

Â  Â  #pragma omp parallel for reduction(+:res)

Â  Â  for (int block = 0; block < num_blocks; block ++){

Â  Â  Â  Â  unsigned long long b_start_ticks = read_time_ticks();

  

Â  Â  Â  Â  size_t vl = __riscv_vsetvl_e32m4(BLOCK_SIZE);

Â  Â  Â  Â  vint32m4_t v_acc_lo = __riscv_vmv_v_x_i32m4(0, vl);

Â  Â  Â  Â  vint32m4_t v_acc_hi = __riscv_vmv_v_x_i32m4(0, vl);

  

Â  Â  Â  Â  const int num_iterations = BLOCK_SIZE / 2;

  

Â  Â  Â  Â  unsigned long long inner_start_ticks = read_time_ticks();

  

Â  Â  Â  Â  for (size_t i = 0; i < num_iterations; i += vl) {

Â  Â  Â  Â  Â  Â  vl = __riscv_vsetvl_e8m1(num_iterations - i);

  

Â  Â  Â  Â  Â  Â  vuint8m1_t v_x_u8 = __riscv_vle8_v_u8m1((const uint8_t *)&x[block].qs[i], vl);

Â  Â  Â  Â  Â  Â  vuint8m1_t v_x_lo_u8 = __riscv_vand_vx_u8m1(v_x_u8, 0x0F, vl);

Â  Â  Â  Â  Â  Â  vuint8m1_t v_x_hi_u8 = __riscv_vsrl_vx_u8m1(v_x_u8, 4, vl);

  

Â  Â  Â  Â  Â  Â  vint8m1_t v_y_lo_i8 = __riscv_vle8_v_i8m1(&y[block].qs[i], vl);

Â  Â  Â  Â  Â  Â  vint8m1_t v_y_hi_i8 = __riscv_vle8_v_i8m1(&y[block].qs[i + BLOCK_SIZE / 2], vl);

  

Â  Â  Â  Â  Â  Â  vint8m1_t v_x_lo_i8 = __riscv_vreinterpret_v_u8m1_i8m1(v_x_lo_u8);

Â  Â  Â  Â  Â  Â  vint8m1_t v_x_hi_i8 = __riscv_vreinterpret_v_u8m1_i8m1(v_x_hi_u8);

  

Â  Â  Â  Â  Â  Â  vint16m2_t v_x_lo_i16 = __riscv_vssub_vx_i16m2(__riscv_vsext_vf2_i16m2(v_x_lo_i8, vl), 8, vl);

Â  Â  Â  Â  Â  Â  vint16m2_t v_x_hi_i16 = __riscv_vssub_vx_i16m2(__riscv_vsext_vf2_i16m2(v_x_hi_i8, vl), 8, vl);

Â  Â  Â  Â  Â  Â  vint16m2_t v_y_lo_i16 = __riscv_vsext_vf2_i16m2(v_y_lo_i8, vl);

Â  Â  Â  Â  Â  Â  vint16m2_t v_y_hi_i16 = __riscv_vsext_vf2_i16m2(v_y_hi_i8, vl);

  

Â  Â  Â  Â  Â  Â  v_acc_lo = __riscv_vwmacc_vv_i32m4(v_acc_lo, v_x_lo_i16, v_y_lo_i16, vl);

Â  Â  Â  Â  Â  Â  v_acc_hi = __riscv_vwmacc_vv_i32m4(v_acc_hi, v_x_hi_i16, v_y_hi_i16, vl);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  unsigned long long inner_end_ticks = read_time_ticks();

  

Â  Â  Â  Â  vl = __riscv_vsetvl_e32m1(1);

Â  Â  Â  Â  vint32m1_t v_zero = __riscv_vmv_v_x_i32m1(0, vl);

Â  Â  Â  Â  size_t vl_src = __riscv_vsetvl_e32m4(BLOCK_SIZE);

Â  Â  Â  Â  vint32m1_t v_red_lo = __riscv_vredsum_vs_i32m4_i32m1(v_acc_lo, v_zero, vl_src);

Â  Â  Â  Â  vint32m1_t v_red_hi = __riscv_vredsum_vs_i32m4_i32m1(v_acc_hi, v_zero, vl_src);

  

Â  Â  Â  Â  int temp_lo = __riscv_vmv_x_s_i32m1_i32(v_red_lo);

Â  Â  Â  Â  int temp_hi = __riscv_vmv_x_s_i32m1_i32(v_red_hi);

Â  Â  Â  Â  int temp = temp_lo + temp_hi;

Â  Â  Â  Â  res += temp * _GGML_CPU_FP16_TO_FP32(x[block].d) * _GGML_CPU_FP16_TO_FP32(y[block].d);

Â  Â  Â  Â  unsigned long long b_end_ticks = read_time_ticks();

  

Â  Â  Â  Â  if (f_rvllm) {

Â  Â  Â  Â  Â  Â  #pragma omp critical

Â  Â  Â  Â  Â  Â  {

Â  Â  Â  Â  Â  Â  Â  Â  fprintf(f_rvllm, "tid=%d block=%d block_ticks=%llu inner_ticks=%llu\n",

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  omp_get_thread_num(), block,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (b_end_ticks - b_start_ticks - ov_ticks),

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (inner_end_ticks - inner_start_ticks - ov_ticks));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  if (f_rvllm) {

Â  Â  Â  Â  fclose(f_rvllm);

Â  Â  }

Â  Â  *result = res;

}
```
### OpenMP

Openmpæœ¬æ¥æƒ³æ”¾åœ¨å¤§å¾ªç¯å¤–é¢ï¼Œä½†æ˜¯å‡ºç°äº†ä¼ªå…±äº«é—®é¢˜ï¼Œç›´æ¥æ…¢äº†2000msï¼Œæ‰€ä»¥è¿™é“é¢˜ä¸çŸ¥é“åº”è¯¥æ€ä¹ˆæ”¾openmpï¼Œä¼°è®¡æ˜¯æ€§èƒ½æœ€å¤§é—®é¢˜

### è®¿å­˜ä¼˜åŒ–

åœ¨è¿™é‡ŒèŠ±äº†éå¸¸å¤šçš„æ—¶é—´ï¼Œæˆ‘å°è¯•å…ˆåŠ è½½ä¸‹ä¸€ç»„æ•°æ®å†åšå¯¹åº”çš„è®¡ç®—

```cpp
    for (int block = 0; block < num_blocks; block ++){ // Iterate by BLOCK
        // åˆå§‹åŒ–ä¸¤ä¸ª32ä½æ•´å‹å‘é‡ç´¯åŠ å™¨ï¼Œç”¨äºå­˜å‚¨ä¸­é—´ç»“æœã€‚
        // `vint32m4_t` è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå…ƒç´ ä¸º32ä½æ•´æ•°ã€LMUL=4çš„å‘é‡ç±»å‹ã€‚
        // LMUL=4æ„å‘³ç€å®ƒä¼šå ç”¨4ä¸ªç‰©ç†å‘é‡å¯„å­˜å™¨ï¼Œæä¾›äº†æ›´å¤§çš„ç´¯åŠ å®¹é‡ã€‚
        // æˆ‘ä»¬ç”¨ `vmv_v_x` æŒ‡ä»¤å°†å®ƒä»¬åˆå§‹åŒ–ä¸º0ã€‚`vsetvl_e32m4` ä¼šè¿”å›å½“å‰é…ç½®ä¸‹å•æ¬¡èƒ½å¤„ç†çš„å…ƒç´ æ•°é‡ã€‚
        size_t vl_acc_init = __riscv_vsetvl_e32m4(BLOCK_SIZE); // ä¸ºç´¯åŠ å™¨è®¾ç½®ä¸€ä¸ªåˆå§‹çš„vl
        vint32m4_t v_acc_lo = __riscv_vmv_v_x_i32m4(0, vl_acc_init);
        vint32m4_t v_acc_hi = __riscv_vmv_v_x_i32m4(0, vl_acc_init);

        // For q4_0 quantization, uint8 is used to store two 4-bit elements
        // The element at low 4 bits and the high bits have an offset of BLOCK_SIZE / 2
        // so when doing vec dot, we need to calculate the low-bit result and the high-bit one separately
        
        const int num_iterations = BLOCK_SIZE / 2;

        //ç¬¬ä¸€æ¬¡åŠ è½½
        size_t vl_curr = __riscv_vsetvl_e8m1(num_iterations);
        // è¿™äº›æ˜¯æ¥è‡ªxå‘é‡çš„ã€æ‰“åŒ…å¥½çš„q4_0é‡åŒ–å€¼ã€‚
        size_t i = 0;
        vuint8m1_t v_x_u8 = __riscv_vle8_v_u8m1((const uint8_t *)&x[block].qs[i], vl_curr);
        // samely we can get the values from vector y
        // const int y_qs_lo = y[block].qs[i];
        // const int y_qs_hi = y[block].qs[i + BLOCK_SIZE / 2];
        vint8m1_t v_y_lo_i8 = __riscv_vle8_v_i8m1(&y[block].qs[i], vl_curr);
        vint8m1_t v_y_hi_i8 = __riscv_vle8_v_i8m1(&y[block].qs[i + BLOCK_SIZE / 2], vl_curr);

        size_t processed_elements = vl_curr;
        while (processed_elements < num_iterations) {
            size_t vl_next = __riscv_vsetvl_e8m1(num_iterations - processed_elements);
            //è¿™é‡Œå…ˆåŠ è½½ä¸‹ä¸€æ¬¡ï¼š
            // è¿™äº›æ˜¯æ¥è‡ªxå‘é‡çš„ã€æ‰“åŒ…å¥½çš„q4_0é‡åŒ–å€¼ã€‚
            vuint8m1_t v_x_u8_next = __riscv_vle8_v_u8m1((const uint8_t *)&x[block].qs[i], vl_next);
            // samely we can get the values from vector y
            // const int y_qs_lo = y[block].qs[i];
            // const int y_qs_hi = y[block].qs[i + BLOCK_SIZE / 2];
            vint8m1_t v_y_lo_i8_next = __riscv_vle8_v_i8m1(&y[block].qs[i], vl_next);
            vint8m1_t v_y_hi_i8_next = __riscv_vle8_v_i8m1(&y[block].qs[i + BLOCK_SIZE / 2], vl_next);

            //å†å¯¹ä¹‹å‰çš„å€¼è¿›è¡Œè®¡ç®—ï¼š
            //const int x_qs_lo = (x[block].qs[i] & 0x0F) - 8; low q4_0 quantized value: 00001111
            vuint8m1_t v_x_lo_u8 = __riscv_vand_vx_u8m1(v_x_u8, 0x0F, vl_curr);
            // const int x_qs_hi = (x[block].qs[i] >> 4) - 8;  // high q4_0 quantized value: 11110000
            vuint8m1_t v_x_hi_u8 = __riscv_vsrl_vx_u8m1(v_x_u8, 4, vl_curr);
            vint8m1_t v_x_lo_i8=__riscv_vreinterpret_v_u8m1_i8m1(v_x_lo_u8);
            vint8m1_t v_x_hi_i8=__riscv_vreinterpret_v_u8m1_i8m1(v_x_hi_u8);

            // åœ¨è¿™é‡Œä¹‹å‰æ”¹æˆæœ‰ç¬¦å·ï¼
            // ç±»å‹æ‰©å±•å’Œå‡å»åå·®ã€‚
            vint16m2_t v_x_lo_i16 = __riscv_vssub_vx_i16m2(__riscv_vsext_vf2_i16m2(v_x_lo_i8, vl_curr), 8, vl_curr);
            vint16m2_t v_x_hi_i16 = __riscv_vssub_vx_i16m2(__riscv_vsext_vf2_i16m2(v_x_hi_i8, vl_curr), 8, vl_curr);

            vint16m2_t v_y_lo_i16 = __riscv_vsext_vf2_i16m2(v_y_lo_i8, vl_curr);
            vint16m2_t v_y_hi_i16 = __riscv_vsext_vf2_i16m2(v_y_hi_i8, vl_curr);

            v_acc_lo = __riscv_vwmacc_vv_i32m4(v_acc_lo, v_x_lo_i16, v_y_lo_i16, vl_curr);
            v_acc_hi = __riscv_vwmacc_vv_i32m4(v_acc_hi, v_x_hi_i16, v_y_hi_i16, vl_curr);

            //å†æŠŠé¢„åŠ è½½çš„æ•°æ®æ›´æ–°ä¸ºä¸‹ä¸€æ¬¡è¿­ä»£çš„ "å½“å‰" æ•°æ®
            v_x_u8 = v_x_u8_next;
            v_y_lo_i8 = v_y_lo_i8_next;
            v_y_hi_i8 = v_y_hi_i8_next;
            vl_curr = vl_next;
            processed_elements += vl_curr;
        }
        //å¯¹æœ€åä¸€ç»„æ•°æ®æ“ä½œ
        //å¯¹ä¹‹å‰çš„å€¼è¿›è¡Œè®¡ç®—ï¼š
        //const int x_qs_lo = (x[block].qs[i] & 0x0F) - 8; low q4_0 quantized value: 00001111
        vuint8m1_t v_x_lo_u8 = __riscv_vand_vx_u8m1(v_x_u8, 0x0F, vl_curr);
        // const int x_qs_hi = (x[block].qs[i] >> 4) - 8;  // high q4_0 quantized value: 11110000
        vuint8m1_t v_x_hi_u8 = __riscv_vsrl_vx_u8m1(v_x_u8, 4, vl_curr);
        vint8m1_t v_x_lo_i8=__riscv_vreinterpret_v_u8m1_i8m1(v_x_lo_u8);
        vint8m1_t v_x_hi_i8=__riscv_vreinterpret_v_u8m1_i8m1(v_x_hi_u8);

        // åœ¨è¿™é‡Œä¹‹å‰æ”¹æˆæœ‰ç¬¦å·ï¼
        // ç±»å‹æ‰©å±•å’Œå‡å»åå·®ã€‚
        vint16m2_t v_x_lo_i16 = __riscv_vssub_vx_i16m2(__riscv_vsext_vf2_i16m2(v_x_lo_i8, vl_curr), 8, vl_curr);
        vint16m2_t v_x_hi_i16 = __riscv_vssub_vx_i16m2(__riscv_vsext_vf2_i16m2(v_x_hi_i8, vl_curr), 8, vl_curr);

        vint16m2_t v_y_lo_i16 = __riscv_vsext_vf2_i16m2(v_y_lo_i8, vl_curr);
        vint16m2_t v_y_hi_i16 = __riscv_vsext_vf2_i16m2(v_y_hi_i8, vl_curr);

        v_acc_lo = __riscv_vwmacc_vv_i32m4(v_acc_lo, v_x_lo_i16, v_y_lo_i16, vl_curr);
        v_acc_hi = __riscv_vwmacc_vv_i32m4(v_acc_hi, v_x_hi_i16, v_y_hi_i16, vl_curr);

        // å½’çº¦ (Reduction) æ“ä½œã€‚
        // åœ¨å‘é‡å¾ªç¯ç»“æŸåï¼Œå’Œå€¼åˆ†å¸ƒåœ¨ç´¯åŠ å™¨å‘é‡çš„å„ä¸ªå…ƒç´ ä¸­ã€‚
        size_t vl_red = __riscv_vsetvl_e32m1(1); // ä¸ºæ ‡é‡å½’çº¦ç»“æœè®¾ç½®vl
        vint32m1_t v_zero = __riscv_vmv_v_x_i32m1(0, vl_red);
        // æ‰§è¡Œå½’çº¦ï¼Œå°†v_acc_lo(m4)ä¸­çš„æ‰€æœ‰å€¼åŠ åˆ°v_zero(m1)ä¸­ã€‚
        size_t vl_src = __riscv_vsetvl_e32m4(BLOCK_SIZE);
        vint32m1_t v_red_lo = __riscv_vredsum_vs_i32m4_i32m1(v_acc_lo, v_zero, vl_src);
        vint32m1_t v_red_hi = __riscv_vredsum_vs_i32m4_i32m1(v_acc_hi, v_zero, vl_src);


        int temp_lo = __riscv_vmv_x_s_i32m1_i32(v_red_lo);
        int temp_hi = __riscv_vmv_x_s_i32m1_i32(v_red_hi);

        int temp = temp_lo + temp_hi; // first merge the result

        // Next we need to get the real value by inverse quantization (* scale factor)
        // The real scale factor is stored in a precomputed table, and here d is the index
        res += temp * _GGML_CPU_FP16_TO_FP32(x[block].d) * _GGML_CPU_FP16_TO_FP32(y[block].d);
    }
```

ä½†äº‹å®çš„ä¼˜åŒ–æ•ˆæœæ˜¯å‡ ä¹æ²¡æœ‰ç”šè‡³å€’é€€ï¼›

äºæ˜¯æˆ‘å°è¯•äº†ä¸€ä¸‹ç”Ÿæˆæ±‡ç¼–ä»£ç æ¥çœ‹æœ‰æ²¡æœ‰çœŸçš„è®¿å­˜ä¼˜åŒ–ï¼Œç”Ÿæˆæ±‡ç¼–çš„æ–¹æ³•æ˜¯åŠ -S

```CMake
target_compile_options(  
	qmatmul PRIVATE  
	-Wall  
	-Wextra  
	-fPIC  
	-O2
	-S
	-Wno-unused-function  
	-march=rv64gcv -mabi=lp64d  
)
```

ä»£ç åœ¨å¦‚ä¸‹ä½ç½®ï¼Œè¿è¡Œæ˜¯è·‘ä¸é€šçš„

![|143](Pasted%20image%2020251026143725.png)

> [!quote]- æ±‡ç¼–
> ```asm
> code Code
> 
> downloadcontent_copy
> 
> expand_less
> 
>     `.file	"qmatmul.c" .option pic .attribute arch, "rv64i2p1_m2p0_a2p1_f2p2_d2p2_c2p0_v1p0_zicsr2p0_zifencei2p0_zve32f1p0_zve32x1p0_zve64d1p0_zve64f1p0_zve64x1p0_zvl128b1p0_zvl32b1p0_zvl64b1p0" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .align	1 .globl	ggml_compute_forward_mul_mat_one_chunk .type	ggml_compute_forward_mul_mat_one_chunk, @function`
>   
> 
> ggml_compute_forward_mul_mat_one_chunk:  
> .LFB147:  
> .cfi_startproc  
> addi sp,sp,-400  
> .cfi_def_cfa_offset 400  
> sd s2,368(sp)  
> sd ra,392(sp)  
> .cfi_offset 18, -32  
> .cfi_offset 1, -8  
> mv s2,a5  
> bge a4,a5,.L22  
> sd s1,376(sp)  
> .cfi_offset 9, -24  
> mv s1,a6  
> bge a6,a7,.L24  
> slli a5,a2,32  
> sd s0,384(sp)  
> srli a5,a5,32  
> .cfi_offset 8, -16  
> mv s0,a4  
> ld a4,160(a1)  
> la a3,type_traits_cpu  
> slli a2,a5,5  
> add a2,a3,a2  
> mv t3,a0  
> lw a0,16(a2)  
> lw a2,0(a4)  
> sd s3,360(sp)  
> sd s4,352(sp)  
> sd s5,344(sp)  
> sd s6,336(sp)  
> sd s7,328(sp)  
> sd s8,320(sp)  
> sd s9,312(sp)  
> sd s10,304(sp)  
> sd s11,296(sp)  
> .cfi_offset 19, -40  
> .cfi_offset 20, -48  
> .cfi_offset 21, -56  
> .cfi_offset 22, -64  
> .cfi_offset 23, -72  
> .cfi_offset 24, -80  
> .cfi_offset 25, -88  
> .cfi_offset 26, -96  
> .cfi_offset 27, -104  
> mv t1,a1  
> beq a2,a0,.L34  
> ld a2,16(t3)  
> sd a2,96(sp)  
> .L5:  
> ld s7,152(t1)  
> slli a5,a5,5  
> add a3,a3,a5  
> ld a5,64(s7)  
> lw a1,16(a4)  
> sd a7,16(sp)  
> sd a5,120(sp)  
> ld a5,72(s7)  
> ld s6,8(a3)  
> ld s4,16(s7)  
> sd a5,128(sp)  
> ld a5,56(t1)  
> ld s8,32(s7)  
> ld s9,40(s7)  
> sd a5,136(sp)  
> ld a5,64(t1)  
> ld s5,56(s7)  
> ld s11,24(a4)  
> sd a5,144(sp)  
> ld a5,72(t1)  
> ld s3,32(a4)  
> ld s10,40(a4)  
> sd t1,8(sp)  
> sd a5,152(sp)  
> call ggml_row_size@plt  
> ld a7,16(sp)  
> sext.w s1,s1  
> sd a0,160(sp)  
> ble a7,s1,.L25  
> divw a5,s3,s8  
> sext.w a4,s3  
> sd a4,112(sp)  
> sext.w s8,s11  
> ld t1,8(sp)  
> sext.w s4,s4  
> addi a3,sp,224  
> divw a4,s10,s9  
> sd a5,168(sp)  
> sext.w a5,s0  
> mv s0,s1  
> slli s1,s5,4  
> mulw s9,s11,s3  
> mv s11,s7  
> mv s7,s8  
> mv s8,a5  
> sd a4,176(sp)  
> mul s10,a5,s5  
> mv a5,s9  
> mv s9,s10  
> mv s10,a5  
> .L16:  
> ble s2,s8,.L6  
> addiw a5,s0,15  
> sd a5,184(sp)  
> mv a1,s11  
> sd s9,208(sp)  
> mv a5,s9  
> addiw s3,s8,15  
> mv s9,s10  
> sd s1,200(sp)  
> mv s10,s7  
> sd s8,216(sp)  
> mv s7,a3  
> sd t1,104(sp)  
> mv s11,s2  
> sd a7,88(sp)  
> mv a3,s8  
> .L7:  
> slli a2,a3,2  
> addiw a4,a3,16  
> sd a2,80(sp)  
> ble a4,s11,.L15  
> mv a4,s11  
> .L15:  
> sub a4,a4,a3  
> slli a4,a4,2  
> sd a4,72(sp)  
> sext.w a4,s0  
> sd a5,64(sp)  
> sd a3,56(sp)  
> mv s2,s0  
> sd s0,192(sp)  
> mv a5,a4  
> mv a0,s7  
> .L10:  
> ld a4,88(sp)  
> ble a4,s2,.L27  
> remw t0,a5,s9  
> ld a4,104(sp)  
> ld a3,176(sp)  
> ld s0,112(sp)  
> ld a2,248(a4)  
> ld a6,128(sp)  
> ld t2,248(a1)  
> ld s1,56(sp)  
> sd s10,8(sp)  
> sd s2,48(sp)  
> mv s7,s1  
> sd a2,16(sp)  
> sd a1,40(sp)  
> mv s2,a0  
> divw a5,a5,s9  
> divw a4,t0,s10  
> divw t3,a5,a3  
> ld a3,168(sp)  
> divw t6,a4,a3  
> remw a3,t0,s10  
> mulw s0,s0,a5  
> mul t3,t3,a6  
> ld a6,120(sp)  
> mulw s0,s0,s10  
> mul t6,t6,a6  
> ld a6,64(sp)  
> addw s0,s0,t0  
> add t3,t3,a6  
> ld a6,160(sp)  
> mul s0,s0,a6  
> ld a6,144(sp)  
> add t3,t3,t6  
> add s8,t2,t3  
> mv s1,s8  
> mv s8,a0  
> mul a4,a4,a6  
> ld a6,96(sp)  
> add s0,a6,s0  
> ld a6,136(sp)  
> mul a3,a3,a6  
> ld a6,152(sp)  
> mv s10,a4  
> mul a5,a5,a6  
> sd a3,24(sp)  
> sd a5,32(sp)  
> .L8:  
> li a7,1  
> li a6,0  
> mv a5,s0  
> li a4,0  
> mv a3,s1  
> li a2,0  
> mv a1,s2  
> mv a0,s4  
> ble s11,s7,.L26  
> jalr s6  
> addi s7,s7,1  
> sext.w a5,s7  
> addi s2,s2,4  
> add s1,s1,s5  
> ble a5,s3,.L8  
> .L26:  
> ld a5,32(sp)  
> ld s0,80(sp)  
> ld a3,24(sp)  
> ld a2,16(sp)  
> add a5,a5,s0  
> mv a4,s10  
> add a5,a5,a3  
> ld s10,8(sp)  
> ld a1,40(sp)  
> ld s2,48(sp)  
> ld a3,72(sp)  
> add a5,a5,a4  
> mv a0,s8  
> add a5,a2,a5  
> mv t1,s8  
> .L9:  
> vsetvli a4,a3,e8,m8,ta,ma  
> vle8.v v8,0(t1)  
> sub a3,a3,a4  
> add t1,t1,a4  
> vse8.v v8,0(a5)  
> add a5,a5,a4  
> bne a3,zero,.L9  
> ld a4,184(sp)  
> addi s2,s2,1  
> sext.w a5,s2  
> bge a4,a5,.L10  
> .L27:  
> ld a3,56(sp)  
> ld a5,64(sp)  
> ld a4,200(sp)  
> addi a3,a3,16  
> ld s0,192(sp)  
> mv s7,a0  
> add a5,a5,a4  
> addiw s3,s3,16  
> blt a3,s11,.L7  
> mv a3,s7  
> ld s8,216(sp)  
> mv s7,s10  
> ld t1,104(sp)  
> mv s10,s9  
> ld a7,88(sp)  
> ld s9,208(sp)  
> mv s2,s11  
> mv s1,a4  
> mv s11,a1  
> .L6:  
> addi s0,s0,16  
> bgt a7,s0,.L16  
> .L25:  
> ld s0,384(sp)  
> .cfi_restore 8  
> ld s1,376(sp)  
> .cfi_restore 9  
> ld s3,360(sp)  
> .cfi_restore 19  
> ld s4,352(sp)  
> .cfi_restore 20  
> ld s5,344(sp)  
> .cfi_restore 21  
> ld s6,336(sp)  
> .cfi_restore 22  
> ld s7,328(sp)  
> .cfi_restore 23  
> ld s8,320(sp)  
> .cfi_restore 24  
> ld s9,312(sp)  
> .cfi_restore 25  
> ld s10,304(sp)  
> .cfi_restore 26  
> ld s11,296(sp)  
> .cfi_restore 27  
> .L22:  
> ld ra,392(sp)  
> .cfi_restore 1  
> ld s2,368(sp)  
> .cfi_restore 18  
> addi sp,sp,400  
> .cfi_def_cfa_offset 0  
> jr ra  
> .L24:  
> .cfi_def_cfa_offset 400  
> .cfi_offset 1, -8  
> .cfi_offset 9, -24  
> .cfi_offset 18, -32  
> ld ra,392(sp)  
> .cfi_restore 1  
> ld s1,376(sp)  
> .cfi_restore 9  
> ld s2,368(sp)  
> .cfi_restore 18  
> addi sp,sp,400  
> .cfi_def_cfa_offset 0  
> jr ra  
> .L34:  
> .cfi_def_cfa_offset 400  
> .cfi_offset 1, -8  
> .cfi_offset 8, -16  
> .cfi_offset 9, -24  
> .cfi_offset 18, -32  
> .cfi_offset 19, -40  
> .cfi_offset 20, -48  
> .cfi_offset 21, -56  
> .cfi_offset 22, -64  
> .cfi_offset 23, -72  
> .cfi_offset 24, -80  
> .cfi_offset 25, -88  
> .cfi_offset 26, -96  
> .cfi_offset 27, -104  
> ld a2,248(a4)  
> sd a2,96(sp)  
> j .L5  
> .cfi_endproc  
> .LFE147:  
> .size ggml_compute_forward_mul_mat_one_chunk, .-ggml_compute_forward_mul_mat_one_chunk  
> .align 1  
> .globl rvllm_vec_dot_q4_0_q8_0  
> .type rvllm_vec_dot_q4_0_q8_0, @function  
> rvllm_vec_dot_q4_0_q8_0:  
> .LFB148:  
> .cfi_startproc  
> sraiw a4,a0,31  
> srliw a4,a4,27  
> li t5,31  
> addw a4,a4,a0  
> ble a0,t5,.L48  
> li t6,32  
> vsetvli t6,t6,e8,m1,ta,ma  
> vsetvli zero,t6,e32,m4,ta,ma  
> vmv.v.i v16,0  
> addi sp,sp,-32  
> .cfi_def_cfa_offset 32  
> vsetivli zero,1,e32,m1,ta,ma  
> addi a2,a5,2  
> sd s0,24(sp)  
> sd s1,16(sp)  
> sd s2,8(sp)  
> sd s3,0(sp)  
> .cfi_offset 8, -8  
> .cfi_offset 9, -16  
> .cfi_offset 18, -24  
> .cfi_offset 19, -32  
> vmv.v.i v12,0  
> addi a0,a3,2  
> vsetivli t3,16,e8,m1,ta,ma  
> addi a6,a2,16  
> li a7,15  
> sraiw t0,a4,5  
> vle8.v v2,0(a6)  
> vle8.v v1,0(a0)  
> vle8.v v3,0(a2)  
> fmv.s.x fa3,zero  
> flw fa0,.LC2,a4  
> flw fa1,.LC1,a4  
> flw ft0,.LC0,a4  
> vmv4r.v v8,v16  
> vmv4r.v v20,v16  
> li t4,0  
> li t1,16  
> li t2,2139095040  
> bgtu t3,a7,.L49  
> .L63:  
> mv a4,t3  
> mv a3,t3  
> vsetvli zero,a4,e8,m1,ta,ma  
> .L38:  
> vand.vi v4,v1,15  
> vsrl.vi v1,v1,4  
> vsetvli zero,zero,e16,m2,ta,ma  
> vsext.vf2 v6,v4  
> vsext.vf2 v4,v1  
> vsext.vf2 v24,v3  
> vsext.vf2 v14,v2  
> vsadd.vi v6,v6,-8  
> vsadd.vi v4,v4,-8  
> mv a5,a4  
> sub a4,t1,a3  
> vsetvli a4,a4,e8,m1,ta,ma  
> vsetvli zero,a5,e16,m2,ta,ma  
> vwmacc.vv v20,v6,v24  
> vwmacc.vv v8,v4,v14  
> add a3,a3,a4  
> vsetvli zero,a4,e8,m1,ta,ma  
> vle8.v v1,0(a0)  
> vle8.v v3,0(a2)  
> vle8.v v2,0(a6)  
> bleu a3,a7,.L38  
> .L37:  
> vand.vi v4,v1,15  
> vsrl.vi v1,v1,4  
> vsetvli zero,zero,e16,m2,ta,ma  
> vsext.vf2 v6,v4  
> vsext.vf2 v4,v1  
> vsext.vf2 v24,v3  
> vsext.vf2 v14,v2  
> vsadd.vi v6,v6,-8  
> vsadd.vi v4,v4,-8  
> lhu a5,-2(a0)  
> vwmacc.vv v20,v6,v24  
> vwmacc.vv v8,v4,v14  
> vsetvli zero,t6,e32,m4,ta,ma  
> srliw a4,a5,10  
> vredsum.vs v20,v20,v12  
> vredsum.vs v8,v8,v12  
> andi s0,a4,31  
> srli s3,a5,15  
> andi s2,a5,1023  
> vmv.x.s a3,v20  
> vmv.x.s s1,v8  
> addw a3,a3,s1  
> fcvt.s.w fa4,a3  
> beq s0,t5,.L60  
> bne s0,zero,.L41  
> fmv.s fa2,fa1  
> beq s3,zero,.L42  
> fmv.s fa2,ft0  
> .L42:  
> fcvt.s.wu fa5,s2  
> fmul.s fa5,fa5,fa0  
> fmul.s fa5,fa5,fa2  
> fmv.x.s a4,fa5  
> .L40:  
> lhu a5,-2(a2)  
> fmv.s.x fa5,a4  
> srliw a4,a5,10  
> andi a6,a4,31  
> fmul.s fa4,fa4,fa5  
> srli s1,a5,15  
> andi s0,a5,1023  
> beq a6,t5,.L61  
> bne a6,zero,.L45  
> fmv.s fa2,fa1  
> beq s1,zero,.L46  
> fmv.s fa2,ft0  
> .L46:  
> fcvt.s.wu fa5,s0  
> fmul.s fa5,fa5,fa0  
> fmul.s fa5,fa5,fa2  
> fmv.x.s a5,fa5  
> .L44:  
> fmv.s.x fa5,a5  
> addiw t4,t4,1  
> addi a0,a0,18  
> fmadd.s fa3,fa4,fa5,fa3  
> addi a2,a2,34  
> ble t0,t4,.L62  
> .L58:  
> vsetivli t3,16,e8,m1,ta,ma  
> addi a6,a2,16  
> vle8.v v2,0(a6)  
> vle8.v v1,0(a0)  
> vle8.v v3,0(a2)  
> vmv4r.v v8,v16  
> vmv4r.v v20,v16  
> bleu t3,a7,.L63  
> .L49:  
> mv a4,t3  
> vsetvli zero,a4,e8,m1,ta,ma  
> j .L37  
> .L61:  
> slliw a5,s0,13  
> slliw a3,s1,31  
> or a3,a3,a5  
> or a5,a3,t2  
> fmv.s.x fa5,a5  
> addiw t4,t4,1  
> addi a0,a0,18  
> fmadd.s fa3,fa4,fa5,fa3  
> addi a2,a2,34  
> bgt t0,t4,.L58  
> .L62:  
> ld s0,24(sp)  
> .cfi_remember_state  
> .cfi_restore 8  
> fsw fa3,0(a1)  
> ld s1,16(sp)  
> .cfi_restore 9  
> ld s2,8(sp)  
> .cfi_restore 18  
> ld s3,0(sp)  
> .cfi_restore 19  
> addi sp,sp,32  
> .cfi_def_cfa_offset 0  
> jr ra  
> .L60:  
> .cfi_restore_state  
> slliw a6,s3,31  
> slliw a5,s2,13  
> or a6,a6,a5  
> or a4,a6,t2  
> j .L40  
> .L45:  
> slliw a5,s0,13  
> slliw a3,s1,31  
> addiw a4,a6,112  
> or a5,a5,a3  
> slli a4,a4,23  
> or a5,a4,a5  
> j .L44  
> .L41:  
> slliw a5,s2,13  
> slliw a6,s3,31  
> addiw a4,s0,112  
> or a5,a5,a6  
> slli a4,a4,23  
> or a4,a4,a5  
> j .L40  
> .L48:  
> .cfi_def_cfa_offset 0  
> .cfi_restore 8  
> .cfi_restore 9  
> .cfi_restore 18  
> .cfi_restore 19  
> fmv.s.x fa3,zero  
> fsw fa3,0(a1)  
> ret  
> .cfi_endproc  
> .LFE148:  
> .size rvllm_vec_dot_q4_0_q8_0, .-rvllm_vec_dot_q4_0_q8_0  
> .section .rodata.cst4,"aM",@progbits,4  
> .align 2  
> .LC0:  
> .word -1199570944  
> .align 2  
> .LC1:  
> .word 947912704  
> .align 2  
> .LC2:  
> .word 981467136  
> .ident "GCC: (Debian 14.2.0-19) 14.2.0"  
> .section .note.GNU-stack,"",@progbits
> ```


æ±‡ç¼–çœ‹ä¸å¤ªæ‡‚ï¼Œé—®AIäº†ï¼Œè¯´æ˜¯æ²¡æœ‰å¯„å­˜å™¨æº¢å‡ºï¼›
åŸå› æ˜¯**ç¼–è¯‘å™¨â€œè¿‡äºæ™ºèƒ½â€ï¼Œç ´åäº†è½¯ä»¶æµæ°´çº¿**

ç„¶åæ”¹ç”¨Clang, Clangå°±æ›´ä¸è¡Œäº†ï¼Œç›´æ¥ä¸åœçš„æº¢å‡ºï¼Œæ‰¾æ–°çš„å¯„å­˜å™¨ï¼Œé‚å’ï¼›
å†…è”æ±‡ç¼–çš„æ•ˆæœä¹Ÿå¾ˆå·®ï¼Œä¸ºäº†å†…è”æ±‡ç¼–åšäº†æ›´å¤šæ“ä½œï¼Œç„¶åå½±å“äº†æ€§èƒ½ã€‚
### Slurmä»»åŠ¡äº¤äº’

```bash
sbatch submit.sh
```

```bash
#!/bin/bash
#SBATCH --job-name=rvllm          # ä½œä¸šåç§°
#SBATCH --partition=riscv         # æäº¤åˆ°çš„åˆ†åŒº
#SBATCH --nodes=1                 # æ‚¨çš„ä»»åŠ¡åªéœ€è¦1ä¸ªèŠ‚ç‚¹
#SBATCH --ntasks=1                # æ‚¨çš„ä»»åŠ¡æ˜¯å•ä¸ªè¿›ç¨‹ï¼Œæ‰€ä»¥ä»»åŠ¡æ•°æ˜¯1
#SBATCH --cpus-per-task=8         # ä¸ºè¿™ä¸ªä»»åŠ¡ç”³è¯·8ä¸ªCPUæ ¸å¿ƒ (llama.cppå¯ä»¥åˆ©ç”¨å¤šæ ¸å¿ƒ)
#SBATCH --time=00:10:00           # é¢„è®¡è¿è¡Œæ—¶é—´ï¼Œå¢åŠ åˆ°10åˆ†é’Ÿä»¥é˜²ç¼–è¯‘å’Œè¿è¡Œè¶…æ—¶
#SBATCH --mail-type=END,FAIL      # åœ¨ä½œä¸šç»“æŸæˆ–å¤±è´¥æ—¶å‘é€é‚®ä»¶
#SBATCH --mail-user=mail@zju.edu  # æ‚¨çš„é‚®ç®±åœ°å€
#SBATCH --output=%x_%j.log      # æ ‡å‡†è¾“å‡ºå’Œé”™è¯¯æ—¥å¿—æ–‡ä»¶

# æ¸…ç†ä¹‹å‰åŠ è½½çš„ä»»ä½•æ¨¡å—ï¼Œç¡®ä¿ç¯å¢ƒå¹²å‡€
module purge

# ç›´æ¥è¿è¡Œæ‚¨çš„ run.sh è„šæœ¬
# ç¡®ä¿ run.sh è„šæœ¬å’Œè¿™ä¸ªæäº¤è„šæœ¬åœ¨åŒä¸€ä¸ªç›®å½•ä¸‹
bash ./run.sh
```
## MC-Ticks

æ²¡æ‹›äº†ï¼Œæ„Ÿè§‰å·²ç»åšä¸äº†äº†

å”¯ä¸€èƒ½è¯¥çš„æ˜¯LightTicks.cpp

è®©AIæ”¹äº†ä¸€ä¸‹OpenMPä¼˜åŒ–ï¼Œæ²¡æœ‰åˆ°èµ·è¯„

```cpp
#include "LightTick.h"
#include "Block.h"
#include "Chunk.h"
#include "ChunkCoord.h"
#include <queue>
#include <vector>

#ifdef USE_OPENMP
#include <omp.h>
#endif

// floodFillLight å‡½æ•°ä¿æŒä¸å˜
void floodFillLight(std::unordered_map<ChunkCoord, Chunk, ChunkCoord::Hash> &chunks, 
    int chunkX, int chunkY,
    int blockX, int blockY, int blockZ, 
    unsigned char lightLevel, std::unordered_map<ChunkCoord, Chunk, ChunkCoord::Hash> &add_chunks) {
        
    // æ–¹å—å…‰ç…§æŒ‰ç…§ Flood Fill ç®—æ³•ä¼ æ’­
    std::queue<std::tuple<int, int, int, int, int, unsigned char, bool>> toVisit;
    toVisit.push({chunkX, chunkY, blockX, blockY, blockZ, lightLevel, true});
    bool source = true;

    while (!toVisit.empty()){
        auto [cX, cZ, bX, bY, bZ, level, fromAbove] = toVisit.front();
        toVisit.pop();

        if (level <= 0) continue;
        if (bX < 0) { bX = 15; cX -= 1; }
        if (bX >= 16) { bX = 0; cX += 1; }
        if (bY < -64 || bY >= 320) continue;
        if (bZ < 0) { bZ = 15; cZ -= 1; }
        if (bZ >= 16) { bZ = 0; cZ += 1; }

        ChunkCoord coord{cX, cZ};
        // ä½¿ç”¨ä¸´ç•ŒåŒºæ¥ä¿æŠ¤å¯¹ add_chunks å’Œ chunks çš„è®¿é—®
        #pragma omp critical
        {
            // å¤„ç†æ–°å¢çš„åŒºå—ï¼Œä½¿ç”¨ä¸€ä¸ªå•ç‹¬çš„ map å­˜å‚¨ï¼Œé˜²æ­¢å¹²æ‰°å…¶æœ¬èº«çš„è¿­ä»£
            if (chunks.find(coord) == chunks.end()){
                if (add_chunks.find(coord) == add_chunks.end()) {
                    add_chunks.emplace(coord, Chunk());
                }
                Chunk &chunk = add_chunks[coord];
                int block_type = chunk.getBlockID(bX, bY, bZ);
                const BlockInfo* info = globalBlockRegistry.getBlockInfo(block_type);

                // å¦‚æœæ–¹å—æ˜¯å®Œå…¨ä¸é€æ˜çš„ï¼Œå¹¶ä¸”ä¸æ˜¯ä»ä¸Šæ–¹æ¥çš„å…‰çº¿ï¼Œåˆ™ä¸ä¼ æ’­
                if (info && info->visualProps.lightOpacity == 15 && !fromAbove) continue;

                unsigned char currentLevel = chunk.getLightLevel(bX, bY, bZ);

                // å¦‚æœå½“å‰å…‰ç…§ç­‰çº§å¤§äºç­‰äºè¦ä¼ æ’­çš„å…‰ç…§ç­‰çº§ï¼Œå¹¶ä¸”ä¸æ˜¯å…‰æºæ–¹å—ï¼Œåˆ™ä¸ä¼ æ’­
                if (currentLevel >= level && !source) continue;

                if (currentLevel < level) {
                    chunk.setLightLevel(bX, bY, bZ, level);
                }
                
                if (info && info->visualProps.lightOpacity == 15 && !source) continue;

                source = false;
                toVisit.push({cX, cZ, bX, bY, bZ - 1, level - 1, false});
                toVisit.push({cX, cZ, bX, bY, bZ + 1, level - 1, false});
                toVisit.push({cX, cZ, bX, bY - 1, bZ, level - 1, true});
                toVisit.push({cX, cZ, bX + 1, bY, bZ, level - 1, false});
                toVisit.push({cX, cZ, bX - 1, bY, bZ, level - 1, false});
                toVisit.push({cX, cZ, bX, bY + 1, bZ, level - 1, false});
                continue;
            } 

            Chunk &chunk = chunks[coord];
            int block_type = chunk.getBlockID(bX, bY, bZ);
            const BlockInfo* info = globalBlockRegistry.getBlockInfo(block_type);

            if (info && info->visualProps.lightOpacity == 15 && !fromAbove) continue;

            unsigned char currentLevel = chunk.getLightLevel(bX, bY, bZ);

            if (currentLevel >= level && !source) continue;

            if (currentLevel < level) {
                chunk.setLightLevel(bX, bY, bZ, level);
            }
            
            if (info && info->visualProps.lightOpacity == 15 && !source) continue;

            source = false;
            toVisit.push({cX, cZ, bX, bY, bZ - 1, level - 1, false});
            toVisit.push({cX, cZ, bX, bY, bZ + 1, level - 1, false});
            toVisit.push({cX, cZ, bX, bY - 1, bZ, level - 1, true});
            toVisit.push({cX, cZ, bX + 1, bY, bZ, level - 1, false});
            toVisit.push({cX, cZ, bX - 1, bY, bZ, level - 1, false});
            toVisit.push({cX, cZ, bX, bY + 1, bZ, level - 1, false});
        }
    }
}


void lightTick(std::unordered_map<ChunkCoord, Chunk, ChunkCoord::Hash> &chunks) {
    std::unordered_map<ChunkCoord, Chunk, ChunkCoord::Hash> add_chunks;
    
    // é˜¶æ®µä¸€: æ¸…ç©ºå…‰ç…§ (å¯ä»¥å¹¶è¡Œ)
    #pragma omp parallel for
    for (auto it = chunks.begin(); it != chunks.end(); ++it) {
        it->second.clearLightData();
    }

    // é˜¶æ®µäºŒ: æ”¶é›†æ‰€æœ‰å…‰æº
    struct LightSource {
        int chunkX, chunkZ;
        int blockX, blockY, blockZ;
        unsigned char lightLevel;
    };
    std::vector<LightSource> lightSources;

    for (auto const& [coord, chunk] : chunks) {
        for (int x = 0; x < 16; ++x) {
            for (int y = -64; y < 320; ++y) {
                for (int z = 0; z < 16; ++z) {
                    int block_type = chunk.getBlockID(x, y, z);
                    const BlockInfo* info = globalBlockRegistry.getBlockInfo(block_type);
                    if (info && info->visualProps.lightEmission > 0) {
                        lightSources.push_back({coord.x, coord.z, x, y, z, info->visualProps.lightEmission});
                    }
                }
            }
        }
    }

    // é˜¶æ®µä¸‰: å¹¶è¡Œå¤„ç†æ‰€æœ‰å…‰æºçš„ Flood Fill
    #pragma omp parallel for
    for (size_t i = 0; i < lightSources.size(); ++i) {
        const auto& source = lightSources[i];
        floodFillLight(chunks, source.chunkX, source.chunkZ, source.blockX, source.blockY, source.blockZ, source.lightLevel, add_chunks);
    }

    // é˜¶æ®µå››: åˆå¹¶æ–°ç”Ÿæˆçš„åŒºå— (ä¸²è¡Œ)
    if (!add_chunks.empty()) {
        chunks.insert(add_chunks.begin(), add_chunks.end());
        add_chunks.clear();
    }
}
```

## æ„Ÿæ‚Ÿ

æœ‰å¾ˆå¤šä¸ä¼šçš„â€¦â€¦

æ„Ÿè§‰é¦–å…ˆæ˜¯å¾—å¥½å¥½çœ‹çœ‹ç ”ç©¶è®¡ç»„å’Œos. è¿›ç¨‹ã€å¯„å­˜å™¨ã€Cache è¿™äº›æ‡‚å¾—å¤ªå°‘äº†

å…¶æ¬¡æ˜¯cppå†™çš„å¤ªä¸ç†Ÿç»ƒï¼Œå¾ˆä¾èµ–AI

æœ€åæ˜¯riscvä¹Ÿå­¦å¾—ä¸å¥½

æ€»ä¹‹å•¥å•¥å†™ä¸å¥½

å¾ˆå¤šä¸œè¥¿çš„åŸç†ä¼¼æ‡‚éæ‡‚å¯¼è‡´æ²¡æœ‰è¯„å®šä¼˜åŒ–çš„èƒ½åŠ›

å…¶æ¬¡å°±æ˜¯ä¸€ç›´æ˜¯ç¨‹å¼åœ°å»ä¼˜åŒ–ä»£ç ï¼Œè€Œä¸æ˜¯é€šè¿‡æ€§èƒ½åˆ†æï¼Œå’Œperf banäº†ä¹Ÿæœ‰å…³ç³»ï¼Œå’Œæˆ‘é™ä¸ä¸‹å¿ƒç ”ç©¶æ›´æœ‰å…³ç³»

è¦æ˜¯æ—¶é—´å¤šä¸€ç‚¹ï¼Œå¯èƒ½ä¼šæ›´ä»”ç»†åœ°ç ”ç©¶ä¸€ä¸‹åˆ°åº•æ€ä¹ˆå»åˆ†æä¸€ä¸ªç¨‹åºçš„æ€§èƒ½ï¼Œä»¥åŠè­¬å¦‚ä¼ªå…±å­˜è¿™äº›æ˜¯ä»€ä¹ˆï¼Œè¿˜æœ‰ä»€ä¹ˆæ–¹æ³•å¯ä»¥ä»ç¡¬ä»¶å±‚é¢ä¼˜åŒ–å§ï¼Œå¦å¤–å°±æ˜¯æ²¡æƒ³åˆ°ä»€ä¹ˆé€»è¾‘ä¸Šä¼˜åŒ–ç®—æ³•çš„ç‚¹ï¼Œæ„Ÿè§‰æ˜¯å¯ä»¥é™ä½ä½†å®Œå…¨æ²¡å°è¯•çš„ã€‚

ä¹‹ååŠ æ²¹å¤šå­¦ä¸€ç‚¹å§ï¼Œå’Œç§‘ç­è¿˜æœ‰å­¦è¿‡çš„åŒå­¦çš„å·®è·è¿˜æ˜¯å¾ˆå¤§çš„ï¼Œå››èˆäº”å…¥ä¸€ä¸ªæ–°ç”Ÿï¼Œå”‰â€¦

