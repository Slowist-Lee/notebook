# Homework 0

主要是代码写的太烂了，另外感觉就是Softmax和NN的一些知识点，到时候也再补到笔记里一下

## 1. 数据集加载

1. `gzip`使用：

`gzip.open()` 得到的是文件指针：16指的是16Bytes（$16 \times 8 = 32 \times 4$）

![|450](Pasted%20image%2020251212135340.png)

```python
with gzip.open(image_filename,'rb') as f_image:
	image=f_image.read(16)
```

2. `struct`使用： struct模块可以将Python中的值（如数字、字符串）打包（pack）成二进制数据，也可以从二进制数据中解包（unpack）出Python的值
- **核心函数**: struct.unpack(format, buffer)
    - **format (格式字符串)**: 定义了如何解释buffer中的字节。
        - `>`: 表示数据是“大端”字节序（big-endian）。这是网络和许多标准文件格式中常见的字节序。
        - `I`: 表示一个无符号整数（unsigned integer），通常占用4个字节。
        - `4I`: 表示连续4个无符号整数。
        - `2I`: 表示连续2个无符号整数。
    - **buffer**: 要解包的二进制数据（bytes对象）。
- **代码实例分析**:
    - `_,num_image,num_row,num_col=struct.unpack('>4I', image)`
        - 这行代码读取了图像文件的前16个字节（因为一个I是4字节，4I就是16字节）。
        - 根据MNIST文件格式，这16个字节包含了幻数（magic number）、图像数量、图像行数和图像列数。
        - struct.unpack将这16个字节解包成4个无符号整数。第一个值（幻数）我们用_忽略了，后面的三个值分别赋给了num_image, num_row, num_col。
    - `_,num_label=struct.unpack('>2I', label)`
        - 这行代码类似地处理标签文件的前8个字节，解包出幻数和标签数量。


## 2. Numpy 使用

1. `numpy` 可以一次性读入数据：

```python
image_data=f_image.read(num_pixels)
X = np.frombuffer(image_data, dtype=np.uint8)
```

2. 转换数据类型：
`astype(np.float32)`/`astype(np.int8)`

3. 重塑数组形状：`.reshape(num_image, num_row*num_col)`: 将一维的像素数组`X`重塑为一个二维数组。数组的行数是图像的数量`num_image`，列数是每张图像的总像素数（$28 \times 28 = 784$）。


4. `np.zeros((shape))`，比如`Iy=np.zeros((num_examples,num_class))`

5. `np.arange(start, stop)`: 创建一个在`[start, stop)`区间内，步长为1的整数序列数组，可以用来创建索引数组


6. **Fancy Index**—— `X[row]`: 通过行索引数组`row`来选取`X`中的特定行，这被称为“花式索引”（Fancy Indexing）。例如，如果`row = [0, 2, 5]`，那么`X[row]`就会取出`X`的第0、2、5行，组成一个新的数组。
    - **代码实例**: `X_input=X[row]`，其中`row`是由`np.arange`生成的连续整数序列，实现了对数据进行分批（batch）处理。

- **高级索引 (Advanced Indexing)**:
  - `Z[rows, y]`: 这是一个非常强大的功能。当使用两个同样长度的数组（这里是`rows`和`y`）作为索引时，`numpy`会将它们配对。`rows`提供行号，`y`提供列号，然后选取`Z`中对应`(行, 列)`位置的元素。
  - **代码实例**: 在`softmax_loss`函数中，`Z[rows, y]`精确地取出了每个样本对应其**真实标签**`y`的那个logit值（预测分数）。这比用循环来实现要高效得多。
  - **代码实例**: `Iy[cols,y_input]=1`，这里`cols`是`np.arange(num_examples)`，`y_input`是该批次样本的真实标签。这行代码将`Iy`矩阵中每个样本（由`cols`指定行）对应其真实标签（由`y_input`指定列）的位置设置为1，从而高效地构建了one-hot编码矩阵。

7. 广播：


>[!NOTE]- "广播规则"
> 1.  如果两个数组的维度数量不同，那么在较小维度的数组的前面补1，直到它们的维度数量相同。
> 2.  如果两个数组在某个维度上的大小相同，或者其中一个数组在该维度上的大小为1，那么这两个数组是兼容的。
> 3.  如果数组在所有维度上都是兼容的，它们就可以被广播。
> 4.  广播后，每个数组的形状都等于两个输入数组在各个维度上大小的最大值。
> 5.  如果一个数组在某个维度上的大小是1，另一个数组的大于1，那么在计算时，`numpy`会沿着该维度“拉伸”或“复制”这个大小为1的数组，使其形状与另一个数组匹配。
> 


- **代码实例分析**:
    - **归一化**: `...astype(np.float32)/255.0`:`numpy`会将标量广播到整个数组的每个元素上，实现每个像素值都除以255.0。
    - **Softmax中的数值稳定性**: `Z=np.exp(data-np.max(data,axis=1).reshape(m, 1))`
        - `np.max(data, axis=1)`: 计算`data`矩阵**每一行**的最大值，结果是一个形状为`(m,)`的一维数组。
        - `.reshape(m, 1)`: 将这个一维数组重塑为形状为`(m, 1)`的二维列向量。
        - `data - ...`: 这里的`data`形状是`(m, num_class)`，而`np.max(...)`的结果是`(m, 1)`。根据广播规则，`numpy`会将`(m, 1)`的列向量**水平复制**`num_class`次，使其形状变为`(m, num_class)`，然后与`data`矩阵进行逐元素的减法。这实现了让`data`矩阵中的每一行都减去该行的最大值，是计算softmax时防止数值溢出的标准技巧。

8. `axis`:`axis=1`: 沿列操作，对每一行求和, `axis=0`: 沿行操作，对每一列求和。

9. `@` 矩阵乘法，`*` 逐元素相乘

