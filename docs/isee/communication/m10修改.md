好的，我已经仔细阅读了您的课程设计要求、理论笔记以及您提供的 C++ 代码草稿。

这份 C++ 代码已经构建了一个非常完整且高质量的 BPSK 通信系统仿真框架，精准地实现了课程设计要求中的各个模块。我的工作将在此基础上进行完善与注释，使其逻辑更清晰，并紧密关联您笔记中的核心理论知识。

以下是根据您的笔记和要求完善后的 C++ 完整代码。

### 完善后的 `BPSK_System.cpp` 文件

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <random>
#include <string>
#include <fstream>
#include <numeric> // 用于 std::accumulate

// 使用标准命名空间，简化代码
using namespace std;

// =================================================================================
// 1. 常量定义 (CONSTANTS DEFINITION)
// =================================================================================
// --- 根据课程设计要求设置系统参数 ---
const double PI = 3.14159265358979323846;
const double BIT_RATE = 100.0;             // 码元速率 (Rb): 100 bps
const double CARRIER_FREQ = 20000.0;       // 载波频率 (fc): 20 kHz
const double ALPHA = 0.3;                  // 滚降因子 (Roll-off factor) for Raised-Cosine filter
const double SYMBOL_PERIOD = 1.0 / BIT_RATE; // 符号周期 (Tb)

// --- 仿真精度相关的关键参数 ---
// 采样率必须远高于载波频率才能准确表示载波信号，避免混叠。
// 根据采样定理，采样率 Fs 至少应为最高信号频率的两倍。对于带通信号，Fs > 2 * (fc + W/2)。
// 在实践中，通常取载波频率的8-16倍以获得平滑的波形。
const int SAMPLING_RATE_FACTOR = 16;
const double SAMPLING_RATE = SAMPLING_RATE_FACTOR * CARRIER_FREQ; // 系统采样率 (Fs = 320 kHz)
const double TS = 1.0 / SAMPLING_RATE;     // 采样时间间隔

// 每个符号的采样点数，由以上参数导出
const int SAMPLES_PER_SYMBOL = static_cast<int>(SAMPLING_RATE / BIT_RATE); // 320000 / 100 = 3200

// =================================================================================
// 2. 辅助函数 (HELPER FUNCTIONS)
// =================================================================================

/**
 * @brief 生成升余弦滤波器脉冲响应。
 *        理论笔记关联: 升余弦滤波器用于基带成形，目的是在不引入码间串扰(ISI)的前提下，
 *        限制信号的传输带宽 W = (1+α)/Ts，实现更高的频谱效率。
 * @param pulseLength 脉冲的总长度（点数）。
 * @param alpha 滚降因子。
 * @param symbolPeriod 符号周期 (Tb)。
 * @param samplingRate 系统采样率 (Fs)。
 * @return 返回一个包含升余弦脉冲样本的向量。
 */
vector<double> raisedCosinePulse(int pulseLength, double alpha, double symbolPeriod, double samplingRate) {
    vector<double> pulse(pulseLength);
    double T = symbolPeriod;

    for (int i = 0; i < pulseLength; ++i) {
        // 将时间轴中心移到脉冲的中心点，以生成一个对称的脉冲
        double t = (i - pulseLength / 2.0) / samplingRate;

        // 处理 t = 0 的特殊情况，避免 sin(0)/0
        if (abs(t) < 1e-9) {
            pulse[i] = 1.0;
        } 
        // 处理 t = +/- T / (2*alpha) 的特殊情况，避免分母为零
        else if (abs(abs(t) - T / (2 * alpha)) < 1e-9) {
            pulse[i] = (PI / 4.0) * sin(PI / (2 * alpha)) / (PI / (2 * alpha));
        }
        // 通用公式
        else {
            double term1 = sin(PI * t / T) / (PI * t / T);
            double term2 = cos(PI * alpha * t / T) / (1.0 - pow(2.0 * alpha * t / T, 2.0));
            pulse[i] = term1 * term2;
        }
    }
    return pulse;
}

/**
 * @brief 将文本字符串转换为二进制比特流 (ASCII编码，每字符8位)。
 * @param text 输入的文本。
 * @return 代表文本的二进制比特流 (vector<int>)。
 */
vector<int> textToBinary(const string& text) {
    vector<int> binarySequence;
    for (char c : text) {
        // 对每个字符，从最高有效位(MSB)到最低有效位(LSB)转换
        for (int i = 7; i >= 0; --i) {
            binarySequence.push_back((c >> i) & 1);
        }
    }
    return binarySequence;
}

/**
 * @brief 将二进制比特流转换回文本字符串 (ASCII编码)。
 * @param binarySequence 输入的二进制比特流。
 * @return 解码后的文本。
 */
string binaryToText(const vector<int>& binarySequence) {
    string text = "";
    // 确保处理的比特数是8的倍数
    size_t totalBits = (binarySequence.size() / 8) * 8;
    for (size_t i = 0; i < totalBits; i += 8) {
        char c = 0;
        for (int j = 0; j < 8; ++j) {
            if (i + j < binarySequence.size()) {
                c |= (binarySequence[i + j] << (7 - j));
            }
        }
        text += c;
    }
    return text;
}

/**
 * @brief 将信号数据保存到文件，用于后续在MATLAB/Python等软件中绘图。
 * @param signal 信号数据。
 * @param filename 文件名。
 */
void saveSignalToFile(const vector<double>& signal, const string& filename) {
    ofstream file(filename);
    if (file.is_open()) {
        for (size_t i = 0; i < signal.size(); ++i) {
            // 第一列是时间，第二列是信号幅值
            file << i * TS << " " << signal[i] << "\n";
        }
        file.close();
    }
}

// =================================================================================
// 3. 通信系统模块 (COMMUNICATION SYSTEM MODULES)
// =================================================================================

/**
 * @brief (a) 基带成形: 将离散的比特序列通过升余弦成形滤波器，生成连续的基带信号。
 *        理论笔记关联: 此处将比特流映射为信号空间中的点。对于BPSK，信号空间是一维的，
 *        两个星座点可以设为 {-A, +A}。这里映射为 {-1, +1}。
 * @param bits 输入的比特序列 {0, 1, ...}。
 * @param pulse 成形滤波器的脉冲响应 (即升余弦脉冲)。
 * @return (a)点信号：成形后的基带信号。
 */
vector<double> basebandShaping(const vector<int>& bits, const vector<double>& pulse) {
    // 1. BPSK映射: 将比特 0 映射为幅度 -1, 比特 1 映射为幅度 +1 (NRZ编码)
    vector<double> symbols;
    for (int bit : bits) {
        symbols.push_back(bit == 0 ? -1.0 : 1.0);
    }

    // 2. 升采样: 在每个符号之间插入 SAMPLES_PER_SYMBOL - 1 个零，以匹配系统采样率
    vector<double> upsampledSymbols(symbols.size() * SAMPLES_PER_SYMBOL, 0.0);
    for (size_t i = 0; i < symbols.size(); ++i) {
        upsampledSymbols[i * SAMPLES_PER_SYMBOL] = symbols[i];
    }
    
    // 3. 卷积: 将升采样后的符号序列与成形脉冲进行卷积，实现脉冲成形
    int outputLength = upsampledSymbols.size() + pulse.size() - 1;
    vector<double> shapedSignal(outputLength, 0.0);
    for (size_t i = 0; i < upsampledSymbols.size(); ++i) {
        if (upsampledSymbols[i] != 0) { // 仅在有符号的位置进行计算以提高效率
            for (size_t j = 0; j < pulse.size(); ++j) {
                shapedSignal[i + j] += upsampledSymbols[i] * pulse[j];
            }
        }
    }

    // 4. 截取稳定部分: 卷积会引入延迟，延迟大小为滤波器长度的一半。截取有效部分信号。
    int delay = pulse.size() / 2;
    vector<double> finalSignal(bits.size() * SAMPLES_PER_SYMBOL);
    for(size_t i=0; i < finalSignal.size(); ++i){
        finalSignal[i] = shapedSignal[i + delay];
    }
    
    return finalSignal;
}

/**
 * @brief (b) BPSK调制: 将基带信号调制到载波上。
 *        理论笔记关联: 调制过程可视为将基带信号向量乘以一个正交基函数(载波)，
 *        将其从基带搬移到通带。
 * @param basebandSignal (a)点信号：基带信号。
 * @return (b)点信号：调制后的带通信号。
 */
vector<double> bpskModulate(const vector<double>& basebandSignal) {
    vector<double> modulatedSignal(basebandSignal.size());
    for (size_t i = 0; i < basebandSignal.size(); ++i) {
        double t = i * TS;
        // 基带信号直接与载波相乘。
        // 乘以 sqrt(2) 是为了使载波信号 cos(2*pi*f*t) 的平均功率归一化为1。
        modulatedSignal[i] = basebandSignal[i] * sqrt(2) * cos(2 * PI * CARRIER_FREQ * t); 
    }
    return modulatedSignal;
}

/**
 * @brief (c) AWGN信道: 向信号中添加高斯白噪声。
 *        理论笔记关联: 这是笔记中讨论的 y(t) = x(t) + n(t) 模型的实现。
 *        噪声向量 n 的各分量是独立同分布的高斯随机变量。
 * @param signal (b)点信号：原始已调信号。
 * @param snrDb 信噪比 (dB)。
 * @return (c)点信号：添加噪声后的信号。
 */
vector<double> addAWGN(const vector<double>& signal, double snrDb) {
    // 1. 计算信号平均功率
    double signalPower = 0.0;
    for (double s : signal) {
        signalPower += s * s;
    }
    signalPower /= signal.size();

    // 2. 从信噪比(dB)计算噪声功率
    double snrLinear = pow(10.0, snrDb / 10.0);
    double noisePower = signalPower / snrLinear;
    double noiseStdDev = sqrt(noisePower); // 噪声标准差

    // 3. 初始化高斯分布随机数生成器
    random_device rd;
    mt19937 gen(rd());
    normal_distribution<double> dist(0.0, noiseStdDev); // 均值为0，标准差为noiseStdDev

    // 4. 将噪声添加到原信号
    vector<double> noisySignal = signal;
    for (size_t i = 0; i < noisySignal.size(); ++i) {
        noisySignal[i] += dist(gen);
    }
    return noisySignal;
}

/**
 * @brief BPSK相干解调与积分: 乘以同频同相载波，并通过积分器（Integrate and Dump）。
 *        理论笔记关联: 这是“最佳接收机”的实现，结构为相关器接收机。
 *        它实现了最大似然(ML)检测准则，对于AWGN信道，这等价于“最小距离检测”。
 *        即将接收信号 y(t) 向基函数(载波)上投影，得到判决统计量。
 * @param noisySignal (c)点信号：接收到的带噪声信号。
 * @return (d)点信号：每个符号周期结束时的积分值（采样值）。
 */
vector<double> coherentDemodulateAndIntegrate(const vector<double>& noisySignal) {
    // 1. 相干解调: 将接收信号乘以同频同相的本地载波 (相关器第一步)
    vector<double> multipliedSignal(noisySignal.size());
    for (size_t i = 0; i < noisySignal.size(); ++i) {
        double t = i * TS;
        multipliedSignal[i] = noisySignal[i] * sqrt(2) * cos(2 * PI * CARRIER_FREQ * t);
    }
    
    // 2. 积分器 (Integrate and Dump): 对每个符号周期内的信号进行积分 (相关器第二步)
    int numSymbols = noisySignal.size() / SAMPLES_PER_SYMBOL;
    vector<double> integratedValues; // 这就是 (d) 点的信号
    for (int i = 0; i < numSymbols; ++i) {
        double integral = 0.0;
        // 在一个符号周期内累加所有采样点的值，作为积分的近似
        for (int j = 0; j < SAMPLES_PER_SYMBOL; ++j) {
            integral += multipliedSignal[i * SAMPLES_PER_SYMBOL + j];
        }
        // 积分结果与采样点累加值成正比，这里直接使用累加值进行后续判决
        integratedValues.push_back(integral);
    }
    return integratedValues;
}

/**
 * @brief (e) 判决器: 根据门限判决积分后的值，恢复出比特流。
 *        理论笔记关联: 实施最小距离检测。对于星座点对称于原点的BPSK({-A, +A})，
 *        最佳判决区域的边界就是垂直平分线，即坐标轴本身，因此判决门限为0。
 * @param integratedValues (d)点信号：积分后的采样值向量。
 * @return (e)点信号：判决出的二进制比特流。
 */
vector<int> decisionDevice(const vector<double>& integratedValues) {
    vector<int> bits;
    // BPSK的最佳判决门限为0
    // 积分值大于0，说明接收向量更靠近代表'1'的星座点；否则更靠近代表'0'的星座点。
    for (double val : integratedValues) {
        bits.push_back(val >= 0 ? 1 : 0);
    }
    return bits;
}


// =================================================================================
// 4. 主函数 (MAIN FUNCTION)
// =================================================================================
int main() {
    // --- 准备工作：生成升余弦脉冲 (一次性生成，供后续重复使用) ---
    // 脉冲长度通常取多个符号周期（如6-8个），以获得较好的带外抑制和时域截断效果
    int pulseDurationInSymbols = 8;
    int pulseLength = pulseDurationInSymbols * SAMPLES_PER_SYMBOL;
    vector<double> rcPulse = raisedCosinePulse(pulseLength, ALPHA, SYMBOL_PERIOD, SAMPLING_RATE);
    
    cout << "=====================================================" << endl;
    cout << "      BPSK Communication System Simulation           " << endl;
    cout << "=====================================================" << endl;

    // --- 任务1: 传输固定序列并保存各点信号用于绘图 ---
    cout << "\n--- Task 1: Fixed Sequence Transmission ---\n" << endl;
    // **修正**: 根据课程设计要求(1)设置输入序列为 000111011101
    vector<int> testSequence = {0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1};
    cout << "Original bits: ";
    for (int bit : testSequence) cout << bit;
    cout << endl;

    // --- 发送端流程 ---
    // (a) 基带成形
    vector<double> basebandSignal_a = basebandShaping(testSequence, rcPulse);
    // (b) BPSK调制
    vector<double> modulatedSignal_b = bpskModulate(basebandSignal_a);

    vector<double> snrList1 = {-5.0, 5.0};
    for (double snr : snrList1) {
        cout << "\nSimulating for SNR = " << snr << " dB..." << endl;

        // --- 信道与接收端流程 ---
        // (c) 加高斯白噪声
        vector<double> noisySignal_c = addAWGN(modulatedSignal_b, snr);
        // (d) 解调与积分
        vector<double> integratedSignal_d = coherentDemodulateAndIntegrate(noisySignal_c);
        // (e) 判决
        vector<int> decodedBits_e = decisionDevice(integratedSignal_d);
        
        cout << "Decoded bits:  ";
        for (int bit : decodedBits_e) cout << bit;
        cout << endl;
        
        // --- 保存各点信号到文件，用于绘图 ---
        // 注意: (e)点是离散比特流，已在上方打印，不适合保存为连续时间波形文件。
        string prefix = "snr_" + to_string((int)snr) + "dB_";
        saveSignalToFile(basebandSignal_a, prefix + "signal_a_baseband.txt");
        saveSignalToFile(modulatedSignal_b, prefix + "signal_b_modulated.txt");
        saveSignalToFile(noisySignal_c, prefix + "signal_c_noisy.txt");

        // (d)点是每个符号末尾的采样值，不是连续信号。将其保存在每个符号末尾的时刻点上。
        ofstream d_file(prefix + "signal_d_integrated_samples.txt");
        for (size_t i = 0; i < integratedSignal_d.size(); ++i) {
            d_file << (i + 1) * SYMBOL_PERIOD << " " << integratedSignal_d[i] << "\n";
        }
        d_file.close();

        cout << "Data files for plotting have been saved with prefix: " << prefix << endl;
    }

    // --- 任务2: 传输文本并给出解调结果（计算误码率） ---
    cout << "\n\n--- Task 2: Text Transmission and BER Calculation ---\n" << endl;
    string testText = "The book is suitable for electronic specialties of engineering school in Chinese general institutions of higher learning as the textbook or reference for the junior and senior students and graduate students, and can also be used as a reference book or a textbook in the advanced study classes for the engineering and technical personnel engaged in communication engineering.";
    cout << "Original text length: " << testText.length() << " characters." << endl;
    
    vector<int> textBinary = textToBinary(testText);
    cout << "Total bits to transmit: " << textBinary.size() << endl;

    // --- 发送端 (一次性完成) ---
    vector<double> textBaseband = basebandShaping(textBinary, rcPulse);
    vector<double> textModulated = bpskModulate(textBaseband);

    vector<double> snrList2 = {-10.0, -5.0, 0.0, 5.0, 10.0};
    cout << "\n--- Demodulated Results (BER) for Different SNRs ---" << endl;
    for (double snr : snrList2) {
        // --- 信道与接收端 ---
        vector<double> textNoisy = addAWGN(textModulated, snr);
        vector<double> textIntegrated = coherentDemodulateAndIntegrate(textNoisy);
        vector<int> textDecodedBits = decisionDevice(textIntegrated);
        
        // --- 计算误比特率 (Bit Error Rate, BER) ---
        // 理论笔记关联: BER是衡量通信系统质量的关键指标。
        // 增加功率(等效于增加SNR)会增大星座点间距d_min，从而降低错误概率Pe，进而降低BER。
        long long errorCount = 0;
        // 确保比较的长度不超过原始比特流的长度
        size_t bitsToCompare = min(textBinary.size(), textDecodedBits.size());
        for (size_t i = 0; i < bitsToCompare; ++i) {
            if (textBinary[i] != textDecodedBits[i]) {
                errorCount++;
            }
        }
        double ber = static_cast<double>(errorCount) / textBinary.size();
        cout << "SNR = " << snr << " dB -> ";
        cout << "BER: " << ber << " (" << errorCount << "/" << textBinary.size() << " errors)" << endl;
    }
    
    return 0;
}
```

---

### 总结：根据笔记进行的修改与完善内容

您提供的原始代码已经是一个功能非常完善的BPSK系统仿真程序。我在此基础上，主要进行了以下两方面的完善：

**1. 精确对齐课程设计要求**

*   **修正输入序列**：在主函数`main()`的任务1部分，我将测试比特序列从 ` {0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1}` **修正为** 课程设计图片中明确要求的 ` {0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1}`。这是确保仿真结果完全符合任务要求所做的最关键的功能性修改。

**2. 结合理论笔记，深化代码内涵与可读性**

我通过添加和修改注释，将代码的实现与您提供的通信原理笔记中的核心理论概念紧密地联系起来。这不仅使代码更易于理解，也清晰地展示了理论是如何指导实践的。主要关联点如下：

*   **基带成形 (Baseband Shaping)**：在 `raisedCosinePulse` 和 `basebandShaping` 函数的注释中，明确了升余弦滤波器的作用是**限制带宽**和**消除码间串扰**，并将比特到幅度的映射（0→-1, 1→+1）解释为**在信号空间中选择星座点**。
*   **最佳接收机理论**：
    *   在 `coherentDemodulateAndIntegrate` 函数的注释中，我明确指出该模块是**“最佳接收机”**的一种工程实现，即**相关器接收机**。
    *   我进一步解释了这种结构背后的理论依据：它等价于笔记中推导的**“最小距离检测”**或**“最大似然检测”**，通过将接收信号向基函数（载波）投影来获得判决统计量。
*   **最佳判决门限**：在 `decisionDevice` 函数的注释中，解释了为什么判决门限设为 `0` 是最佳的。这源于BPSK的两个星座点 `{-A, +A}` 关于原点对称，其**判决区域的边界**（垂直平分线）正好是原点。
*   **AWGN信道模型**：在 `addAWGN` 函数处，注释强调了其实现与笔记中的 `y(t) = x(t) + n(t)` 模型一致。
*   **性能衡量**：在任务2计算BER的部分，注释关联了笔记中的核心权衡关系：**提高信噪比（SNR）可以增大星座点间距，从而降低错误概率（Pe），最终体现为误比特率（BER）的下降**。

通过以上完善，这份C++代码不仅能正确地完成课程设计的所有仿真任务，而且其每一部分都附带了清晰的理论依据，充分体现了对《通信原理》课程知识的深刻理解与应用。