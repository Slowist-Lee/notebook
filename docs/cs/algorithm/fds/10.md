# 其他

arbitrary：任意的

当然可以！通过一个具体的例子来演示是理解这两个算法最好的方式。

我们将使用同一个例子来对比这两个算法：
*   **文本 (Text)**: `T = "TRUST_HARD_WORK_AND_TRUST_YOURSELF"`
*   **模式 (Pattern)**: `P = "TRUST"`

---

### 1. Horspool 算法示例

#### 第一步：预计算 - 创建移动表 (Shift Table)
*   模式 `P = "TRUST"`，长度 `m = 5`。
*   规则：
    *   未在 `P[0...3]` 中出现的字符，移动值为 `m=5`。
    *   在 `P[0...3]` 中出现的字符 `c`，移动值为 `m - 1 - c的最后出现位置`。

| 字符 `c` | T | R | U | S | 其他所有字符 (`_`, `H`, `A`, `D`...) |
| :--- | :-: | :-: | :-: | :-: | :---: |
| **移动值** | 4 | 3 | 2 | 1 | 5 |
*(计算过程：T在索引0，所以 5-1-0=4；R在索引1，所以 5-1-1=3...)*

#### 第二步：匹配过程
我们将用 `|` 符号表示模式串的覆盖范围。

**第1次尝试:**
```
T: |TRUST|_HARD_WORK_AND_TRUST_YOURSELF
P:  TRUST
```
1.  **检查点**: 文本中与模式串最后一个字符'T'对齐的字符是 `T[4]`，即**'T'**。
2.  **决策**: 查移动表，`T['T']` 的移动值是 **4**。
3.  **移动**: 将模式串向右移动4位。

**第2次尝试:**
```
T: TRUST|_HARD|_WORK_AND_TRUST_YOURSELF
P:      TRUST
```
1.  **检查点**: 文本中与模式串最后一个字符'T'对齐的字符是 `T[8]`，即**'H'**。
2.  **决策**: 查移动表，'H'是“其他字符”，移动值是 **5**。
3.  **移动**: 将模式串向右移动5位。

**第3次尝试:**
```
T: TRUST_HARD|_WORK_|_AND_TRUST_YOURSELF
P:           TRUST
```
1.  **检查点**: 文本中与模式串最后一个字符'T'对齐的字符是 `T[13]`，即**'K'**。
2.  **决策**: 查移动表，'K'是“其他字符”，移动值是 **5**。
3.  **移动**: 将模式串向右移动5位。

**第4次尝试:**
```
T: TRUST_HARD_WORK|_AND_|_TRUST_YOURSELF
P:                 TRUST
```

1.  **检查点**: 文本中与模式串最后一个字符'T'对齐的字符是 `T[18]`，即**'_'**。
2.  **决策**: 查移动表，'_'是“其他字符”，移动值是 **5**。
3.  **移动**: 将模式串向右移动5位。

**第5次尝试:**
```
T: TRUST_HARD_WORK_AND|_TRUST|_YOURSELF
P:                       TRUST
```
1.  **检查点**: 文本中与模式串最后一个字符'T'对齐的字符是 `T[28]`，即**'T'**。
2.  **比较**: 既然检查点字符在模式串里，我们开始**从右向左**比较。
    *   `T[28]` vs `P[4]` ('T' vs 'T') -> **匹配**
    *   `T[27]` vs `P[3]` ('S' vs 'S') -> **匹配**
    *   `T[26]` vs `P[2]` ('U' vs 'U') -> **匹配**
    *   `T[25]` vs `P[1]` ('R' vs 'R') -> **匹配**
    *   `T[24]` vs `P[0]` ('T' vs 'T') -> **匹配**
3.  **结果**: 完全匹配！在文本索引 **24** 处找到模式串。

---

### 2. Boyer-Moore 算法示例

Boyer-Moore 更复杂，因为它有两个规则。

#### 第一步：预计算
*   模式 `P = "TRUST"`，长度 `m = 5`。

**A. 坏字符表 (Bad Character Table)**
*   记录每个字符在模式串中最后出现的位置。

| 字符 `c` | T | R | U | S |
| :--- | :-: | :-: | :-: | :-: |
| **索引** | 4 | 1 | 2 | 3 |

**B. 好后缀表 (Good Suffix Table)**
*   为每个可能的好后缀计算移动距离。
*   `gs[k]` 表示当长度为 `k` 的好后缀发生失配时，应该移动多少位。

| 好后缀长度 `k` | 好后缀 `s` | 移动距离 `gs[k]` |
| :--- | :--- | :--- |
| 1 | "T" | 4 (将 `TRUS**T**` 对齐到 `**T**RUST`) |
| 2 | "ST" | 4 (找不到"ST"，但"ST"的后缀"T"是P的前缀，将`TRU**ST**`对齐到`**T**RUST`) |
| 3 | "UST" | 4 (同上) |
| 4 | "RUST"| 4 (同上) |

#### 第二步：匹配过程

**第1次尝试:**
```
T: |TRUST|_HARD_WORK_AND_TRUST_YOURSELF
P:  TRUST
```
1.  **比较**: 从右向左比较，`T[4]` vs `P[4]` ('T' vs 'T')，匹配。`T[3]` vs `P[3]` ('S' vs 'S')，匹配... 全部匹配。
2.  **结果**: 在文本索引 **0** 处找到模式串。
3.  **为寻找下一个匹配而移动**:
    *   **坏字符规则**: 不适用，因为没有不匹配。
    *   **好后缀规则**: 我们可以认为整个字符串是一个好后缀。应用好后缀规则的变种，我们查找 `P` 的最长前缀，它同时也是 `P` 的后缀。这里是 "T"。所以我们将下一个"T"对齐。移动距离是4。

**第2次尝试:**
```
T: TRUST|_HARD|_WORK_AND_TRUST_YOURSELF
P:      TRUST
```
1.  **比较**: `T[8]` ('H') vs `P[4]` ('T') -> **不匹配**。
2.  **决策**:
    *   **坏字符规则**: 坏字符是文本中的'H'。'H'不在 `P` 中。不匹配发生在 `P` 的索引4。移动 `4 - (-1) = 5` 位。
    *   **好后缀规则**: 没有好后缀（长度为0）。移动值为1（这是默认的最小安全移动）。
    *   `max(5, 1) = 5`。
3.  **移动**: 将模式串向右移动 **5** 位。

**第3次尝试:**
```
T: TRUST_HARD|_WORK_|_AND_TRUST_YOURSELF
P:           TRUST
```
1.  **比较**: `T[13]` ('K') vs `P[4]` ('T') -> **不匹配**。
2.  **决策**:
    *   **坏字符规则**: 坏字符是'K'，不在`P`中。移动 `4 - (-1) = 5` 位。
    *   **好后缀规则**: 没有好后缀。移动 1 位。
    *   `max(5, 1) = 5`。
3.  **移动**: 将模式串向右移动 **5** 位。

**第4次尝试:**
```
T: TRUST_HARD_WORK|_AND_|_TRUST_YOURSELF
P:                 TRUST
```

1.  **比较**: `T[18]` ('_') vs `P[4]` ('T') -> **不匹配**。
2.  **决策**:
    *   **坏字符规则**: 坏字符是'_'，不在`P`中。移动 `4 - (-1) = 5` 位。
    *   **好后缀规则**: 没有好后缀。移动 1 位。
    *   `max(5, 1) = 5`。
3.  **移动**: 将模式串向右移动 **5** 位。

**第5次尝试:**
```
T: TRUST_HARD_WORK_AND|_TRUST|_YOURSELF
P:                       TRUST
```
1.  **比较**: 从右向左比较，发现完全匹配。
2.  **结果**: 在文本索引 **24** 处找到模式串。

### 总结对比

在这个例子中，两个算法的跳跃步数恰好相同，都非常高效地跳过了大量不必要的比较。
*   **Horspool** 仅凭一个简单的移动表就实现了巨大的跳跃。
*   **Boyer-Moore** 虽然逻辑更复杂，但它的决策过程（坏字符 vs 好后缀）让它在理论上能应对更复杂的情况，做出最优的跳跃决策。
