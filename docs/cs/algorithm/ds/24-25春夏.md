一、选择题（10\*3）
冒泡排序，Floyd&Dijkstra比较，深度优先/广度优先查找，Lomuto划分，Warshall算法求第三个邻接矩阵，Prim或Krustal求生成树。其他的还没记起来，有部分和以下作业题类似：

![](Pasted%20image%2020260114125125.png)

![](Pasted%20image%2020260114125131.png)

![](Pasted%20image%2020260114125137.png)

二、填空题（4\*4）

二叉树，给出前序、中序的排序，求后序，其他的还没记起来（雾）


三、大题（可能有细节错误，轻喷）

1.闭散列，给了7个关键字，链表是10个位置，求最后的链表+平均比较次数

2.最大堆  （1）忘了 （2）删除最大值两次，演示过程，给出最终堆的状态。  （3）在（2）的结果下加入一个“7”，演示过程，给出最终堆的状态。

3.拓扑    起始点A到各节点最短距离及其路径（图没记清，好在应该不难）

4.设计题：n节视频文件需要上传，文件上传所需时间（或内存？）不同。可以将相邻的视频文件合并，此时合成新文件的上传所需时间是两个组成部分中较大的那一个的时间，最终上传的每个视频最多可以由k个视频合并而成，请设计算法来得到上传这些视频所需的较短的时间。

5.设计题：

给你一个整数数组 `cookies` ，其中 `cookies[i]` 表示在第 `i` 个零食包中的饼干数量。另给你一个整数 `k` 表示等待分发零食包的孩子数量，**所有** 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。

分发的 **不公平程度** 定义为单个孩子在分发过程中能够获得饼干的最大总数。

返回所有分发的最小不公平程度。

**示例 1：**

**输入：** cookies = [8,15,10,20,8], k = 2
**输出：** 31
**解释：** 一种最优方案是 [8,15,8] 和 [10,20] 。
- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。
- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。
分发的不公平程度为 max(31,30) = 31 。
可以证明不存在不公平程度小于 31 的分发方案。

**示例 2：**

**输入：** cookies = [6,1,3,2,2,4,1,2], k = 3
**输出：** 7
**解释：** 一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。
- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 
- 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。
- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。
分发的不公平程度为 max(7,7,7) = 7 。
可以证明不存在不公平程度小于 7 的分发方案。

**提示：**

- `2 <= cookies.length <= 8`
- `1 <= cookies[i] <= 105`
- `2 <= k <= cookies.length`