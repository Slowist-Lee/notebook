# Chap 2: Language of Machine

这一部分前辈的笔记写的太好了：
致谢 https://note.noughtq.top/sys/co/2 




%% 总是有类似的顺序（这样指令不用总是找目标寄存器/源寄存器）

![](Pasted%20image%2020251120164048.png)
加/减法

格式

长算式：会break up，放到临时寄存器

可以优化（通常就是在减少寄存器数量）

逐步


![](Pasted%20image%2020251120164335.png)

立即数

numerical constant

addi x3, x4, 10 : f=g+10

没有 subi

addi x3, x4, -10 (补码)
f=g-10

零寄存器，永远硬编码为0，（0太常见了）x0=0
add x0,x3,x4（没用）

![](Pasted%20image%2020251120164740.png)

最多32个寄存器（除去0，31个），还会用一些别的

寄存器使用：

![](Pasted%20image%2020251120165145.png)

![](Pasted%20image%2020251120165342.png)
正好match


Each word of 32 bits will fit 4 bytes, eight bits each 每个32位的字容纳4个字节，每个字节8bit

内存中存储字节到字的顺序：

小端序：Little-endian

![](Pasted%20image%2020251120165700.png)

本质上字的地址和最低有效字节的地址一样

![](Pasted%20image%2020251120170024.png)

![](Pasted%20image%2020251120170406.png)

![](Pasted%20image%2020251120170451.png)
Data Transfer Instructions

![](Pasted%20image%2020251120170639.png)

DRAM比Processor慢100倍

从内存中获取数据是昂贵的

![](Pasted%20image%2020251120171704.png)



![](Pasted%20image%2020251120171558.png)

格式：

```assembly
load reg, offset(mem_base_addr)
// load: load instruction, be cautious that there's no actual 
//       instruction called "load", which is just a placeholder
// reg: register
// mem_base_addr: a register containing the base address of memory, 
//                also called base register
// offset: constant
```

注意：没有声明和分配数组，只有搬移

store register to memory

 %%

 ![](Pasted%20image%2020251125201002.png)

 ![](Pasted%20image%2020251125201016.png)

 ![](Pasted%20image%2020251125201110.png)
 