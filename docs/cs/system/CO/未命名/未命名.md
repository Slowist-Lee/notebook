好的，请看以下参考答案。

***

### **1. (20分) 流水线冒险分析**

#### **(a) 仅通过停顿解决冒险 (无转发)**

在仅使用停顿解决冒险的情况下，流水线需要处理由于分支指令和数据依赖引起的冲突。

*   **控制冒险 (Control Hazard):**
    *   **涉及指令:** 第1行的 `beq x0 x0 Label` 指令，以及因错误预测而进入流水线的第2、3、4行指令。
    *   **描述:** `beq` 指令在流水线的MEM阶段（周期 4）才确定其分支目标。由于CPU预测分支不发生，它会顺序取出 `beq` 之后的3条 `addi` 指令。当在周期4发现分支实际发生时，这3条已经进入流水线的指令（分别处于ID, EX, MEM阶段前一级）必须被清除，并从正确的`Label`地址（第7行）重新取指。
    *   **所需停顿:** 清除这3条指令并重新取指需要 **3个时钟周期** 的停顿（或称为流水线冲刷）。

*   **数据冒险 (Data Hazard):**
    *   **涉及指令:** 第7行的 `addi t0, x0, 9` 和第8行的 `addi t1, t0, 2`。
    *   **描述:** 第8条指令需要使用寄存器 `t0` 的值，而这个值是由第7条指令计算得出的。在没有转发路径的情况下，第8条指令必须等待第7条指令完成其WB（写回）阶段，才能从寄存器堆中读取到正确的 `t0` 值。第7条指令在周期9完成WB，因此第8条指令的EX阶段必须等到周期10才能开始。
    *   **所需停顿:** 这导致了 **2个时钟周期** 的停顿。

**流水线执行过程:**

| 周期 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 1 beq | IF | ID | EX | MEM | WB | | | | | | | | |
| 2 addi| | IF | ID | EX | flush| | | | | | | | |
| 3 addi| | | IF | ID | flush| | | | | | | | |
| 4 addi| | | | IF | flush| | | | | | | | |
| 7 addi| | | | | IF | ID | EX | MEM| WB | | | | |
| 8 addi| | | | | | IF | ID | S | S | EX | MEM| WB | |
| 9 xori| | | | | | | IF | ID | S | S | EX | MEM| **WB** |

**结论:** 第9行的 `xori` 指令在 **第13个时钟周期** 执行其WB阶段。

#### **(b) 实现双泵(double pumping)和所有转发路径**

在实现转发路径后，大部分数据冒险可以被解决。

*   **控制冒险 (Control Hazard):**
    *   **涉及指令:** 第1行的 `beq` 指令，以及第2、3、4行指令。
    *   **描述:** 与(a)部分相同。转发路径无法解决因分支预测错误导致的控制冒险。分支决策仍在MEM阶段做出，因此流水线仍需冲刷掉3条错误取入的指令。
    *   **所需停顿:** **3个时钟周期**。

*   **数据冒险 (Data Hazard):**
    *   **涉及指令:** 第7行的 `addi t0, x0, 9` 和第8行的 `addi t1, t0, 2`。
    *   **描述:** 第8条指令在EX阶段需要 `t0` 的值。此时，第7条指令已经完成了它的EX阶段，其结果位于EX/MEM流水线寄存器中。通过转发，这个结果可以直接从EX/MEM寄存器传递给第8条指令的ALU输入端，无需等待WB阶段。
    *   **所需停顿:** **0个时钟周期**。

**流水线执行过程:**

| 周期 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 1 beq | IF | ID | EX | MEM | WB | | | | | | |
| 2 addi| | IF | ID | EX | flush| | | | | | |
| 3 addi| | | IF | ID | flush| | | | | | |
| 4 addi| | | | IF | flush| | | | | | |
| 7 addi| | | | | IF | ID | EX | MEM| WB | | |
| 8 addi| | | | | | IF | ID | EX | MEM| WB | |
| 9 xori| | | | | | | IF | ID | EX | MEM| **WB** |

**结论:** 第9行的 `xori` 指令在 **第11个时钟周期** 执行其WB阶段。

***

### **2. (24分) 缓存(Cache)问题**

#### (a) 缓存有多少个块(block)?
$$ \text{块数} = \frac{\text{缓存总大小}}{\text{块大小}} = \frac{64 \text{ 字节}}{8 \text{ 字节}} = 8 \text{ 块} $$
缓存共有 **8** 个块。

#### (b) 地址中的Tag字段需要多少位(bit)?
1.  **块偏移(Block Offset):** 块大小为8字节 ($2^3$ 字节)，因此偏移需要 $3$ 位。
2.  **组索引(Index):** 缓存共有8个块，且为2路组相联，所以组数为 $\frac{8 \text{ 块}}{2 \text{ 路}} = 4$ 组。索引需要 $\log_2(4) = 2$ 位。
3.  **标记(Tag):** 地址总位数为8位。因此Tag位数 = 总位数 - 索引位数 - 偏移位数。
    $$ \text{Tag位数} = 8 - 2 - 3 = 3 \text{ 位} $$
Tag字段需要 **3** 位。

#### (c) 根据访问序列，判断命中(H)或缺失(M)
地址格式: **Tag (3位)**, **Index (2位)**, **Offset (3位)**

| Hex Address | Binary Address | Tag | Index | H/M |
| :---: | :---: | :-: | :---: | :-: |
| 00 | 0000 0000 | 000 | 00 | **M** |
| 20 | 0010 0000 | 001 | 00 | **M** |
| 06 | 0000 0110 | 000 | 01 | **M** |
| 85 | 1000 0101 | 100 | 00 | **M** |
| 07 | 0000 0111 | 000 | 01 | **H** |
| F1 | 1111 0001 | 111 | 10 | **M** |
| 33 | 0011 0011 | 001 | 10 | **M** |
| F0 | 1111 0000 | 111 | 10 | **H** |
| 21 | 0010 0001 | 001 | 00 | **H** |

***

### **3. (30分) 平均内存访问时间 (AMAT)**

#### (a) 机器A的平均内存访问时间 (AMAT) 是多少?
$$ \text{AMAT}_A = (\text{L1命中时间}) + (\text{L1缺失率}) \times (\text{L1缺失代价}) $$
$$ \text{AMAT}_A = 6 \text{ ns} + 0.10 \times 80 \text{ ns} = 6 + 8 = 14 \text{ ns} $$

#### (b) 机器B的平均内存访问时间 (AMAT) 是多少?
$$ \text{AMAT}_B = (\text{L1命中时间}) + (\text{L1缺失率}) \times (\text{L2 AMAT}) $$
$$ \text{L2 AMAT} = (\text{L2命中时间}) + (\text{L2缺失率}) \times (\text{主存访问时间}) $$
$$ \text{L2 AMAT} = 20 \text{ ns} + 0.25 \times 80 \text{ ns} = 20 + 20 = 40 \text{ ns} $$
$$ \text{AMAT}_B = 2 \text{ ns} + 0.20 \times 40 \text{ ns} = 2 + 8 = 10 \text{ ns} $$

#### (c) 如果降低机器A的缓存缺失率，使其AMAT与机器B相同，那么机器A新的缓存缺失率是多少?
设机器A新的缺失率为 $MR'_A$。
$$ \text{AMAT}_{A'} = \text{AMAT}_B $$
$$ 6 \text{ ns} + MR'_A \times 80 \text{ ns} = 10 \text{ ns} $$
$$ MR'_A \times 80 = 4 $$
$$ MR'_A = \frac{4}{80} = 0.05 $$
新的缓存缺失率应为 **5%**。

***

### **4. (26分) 虚拟内存**

#### (a) 页面偏移(page offset)需要 **12** 位。虚拟页号(virtual page number)需要 **20** 位。
*   页面大小为 4 KiB = $2^{12}$ 字节，所以页偏移需要12位。
*   虚拟地址为32位，所以虚拟页号(VPN)需要 $32 - 12 = 20$ 位。

#### (b) 给定虚拟字节地址 0x08131:
*   **地址分解:** 虚拟地址 `0x00008131`。页偏移为后12位 `0x131`，VPN为前20位 `0x00008`。
*   **TLB查询:** TLB为4项直接映射，TLB索引 = VPN mod 4 = $8 \pmod 4 = 0$。TLB Tag = VPN / 4 = $8 / 4 = 2$。
*   查询TLB索引0，其Tag为`02`，与计算出的Tag相符，且valid位为1。

VPN is 0x **08** , TLB tag is 0x **02** . TLB miss or hit? **Hit**. The physical address is 0x **57131** .
*   **物理地址:** 从TLB中得到物理页号(PPN)为`0x57`。物理地址 = PPN + Offset = `0x57` + `0x131` = `0x57131`。

#### (c) 给定虚拟字节地址 0x0F152:
*   **地址分解:** 虚拟地址 `0x0000F152`。页偏移为 `0x152`，VPN为 `0x0000F` (即十进制15)。
*   **TLB查询:** TLB索引 = VPN mod 4 = $15 \pmod 4 = 3$。TLB Tag = VPN / 4 = $\lfloor 15/4 \rfloor = 3$。
*   查询TLB索引3，其Tag为`01`，与计算出的Tag `03` 不符。

VPN is 0x **0F** , TLB tag is 0x **03** . TLB miss or hit? **Miss**. The physical address is 0x **48152** .
*   **页表查询:** TLB缺失，查询页表。在页表中查找VPN `0F`，找到对应条目，valid位为1，其PPN为`0x48`。
*   **物理地址:** 物理地址 = PPN + Offset = `0x48` + `0x152` = `0x48152`。

![](Pasted%20image%2020251225110600.png)
