好的，我们来逐一分析这些题目，并由此串讲 I/O、中断等相关的知识点。

### 核心知识点讲解

#### 1. I/O (输入/输出) 系统

计算机系统由中央处理器 (CPU)、内存和 I/O 设备组成。I/O 系统是计算机与外部世界（包括用户和其他设备）沟通的桥梁。

*   **问题 3 解析**: 中央系统（CPU和内存）与外部环境（如键盘、鼠标、显示器、硬盘）之间的通信正是通过 **A: 输入-输出子系统 (Input-output subsystem)** 来完成的。这是 I/O 系统的基本定义。

#### 2. I/O 控制方式

CPU 需要与 I/O 设备同步，以确保数据在正确的时间被传输。主要有三种方式：

1.  **轮询 (Polling)**: CPU 主动、反复地去查询 I/O 设备的状态，看它是否准备好。这种方式就像你一直问“好了吗？好了吗？”，会占用大量 CPU 时间。
    *   **问题 7 解析**: **A: 轮询 (Polling)** 是最简单的方式，CPU 只需要不断读取设备的状态寄存器即可，因此它需要的硬件支持最少。相比之下，中断需要中断控制器，而 DMA 则需要更复杂的 DMA 控制器。

2.  **中断 (Interrupt)**: I/O 设备在准备好时，会主动向 CPU 发送一个信号（中断请求）。CPU 接收到信号后，会暂停当前正在执行的任务，转而去处理这个 I/O 事件（这个处理过程称为“中断服务程序”），处理完毕后再返回原来的任务。这种方式变被动为主动，大大提高了 CPU 的效率。
    *   **问题 5 解析**: 设备在准备好时发送信号来同步处理器的方法是 **C: 中断 (Interrupts)**。这是中断驱动 I/O 的核心思想。

3.  **直接内存访问 (DMA - Direct Memory Access)**: 对于大量数据的传输（如读写硬盘），如果还让 CPU 参与，效率会很低。DMA 允许 I/O 设备在 DMA 控制器的协调下，直接与内存进行数据交换，而不需要 CPU 的介入。CPU 只需在传输开始前设置好 DMA 控制器（源地址、目标地址、数据长度等），并在传输结束后接收一个中断信号即可。
    *   **问题 9 解析**: 这个说法是 **错误 (False)** 的。对于**大块数据**的传输，DMA 的效率远高于中断。虽然 DMA 的设置过程（setup）本身有开销，但一旦设置好，数据传输就不再占用 CPU，极大地释放了 CPU 资源。因此，对于大量数据传输，DMA 的优势非常明显。

#### 3. 中断 (Interrupts) 与子程序 (Subroutines)

这两者虽然在执行流程上都涉及跳转和返回，但有本质区别。

| 特性 | 子程序 (Subroutine) | 中断 (Interrupt) |
| :--- | :--- | :--- |
| **调用方式** | 由程序中的指令（如 `CALL`）调用，是**软件层面**的、**可预测**的。 | 由硬件或软件异常事件触发，是**硬件或异常事件**驱动的、**异步**的。 |
| **发起者** | 程序员在代码中安排。 | 外部设备、硬件错误、程序异常（如除以零）。 |
| **目的** | 完成一个特定的、预设的功能模块。 | 响应一个紧急的、外部的或异常的事件。 |

*   **问题 1 解析**:
    *   (i) 两者都有返回语句（子程序用 `RET`，中断用 `IRET` 等），正确。
    *   (ii) 两者都会改变程序计数器 (PC) 的内容以跳转到新的地址，正确。
    *   (iii) 子程序是软件导向的，但中断主要是硬件或异常事件导向的。所以这个说法**错误**。
    *   (iv) 用户可以通过指令调用子程序，但通常不能直接“发起”一个硬件中断（尽管可以通过特定操作间接触发）。所以这个说法**错误**。
    *   因此，错误的陈述是 (iii) 和 (iv)，答案是 **D**。

*   **问题 8 解析**: 当中断服务完成后，系统需要恢复被中断进程的执行环境，就好像它从未被打断过一样。这称为“上下文恢复”(Context Restore)。需要恢复的内容包括：
    *   **i) 寄存器内容**: 通用寄存器、状态寄存器等的值。
    *   **ii) 条件码**: 也叫程序状态字 (PSW) 或标志寄存器 (Flags Register)，记录了上一步运算的结果状态（如是否为零、是否溢出等）。
    *   中断返回地址通常由硬件自动处理（比如从堆栈中弹出PC），而堆栈内容本身是为了保存这些信息而改变的，恢复的是寄存器而不是堆栈本身。因此，最关键的是恢复寄存器的内容和条件码。
    *   所以答案是 **D. i, ii**。

*   **问题 10 解析**: 中断的来源非常广泛。
    *   A: 程序错误，如除以零、算术溢出，会引发**异常 (Exception)**，这是一种内部中断。
    *   B: 硬件故障，如内存校验错误。
    *   C: I/O 操作完成或需要服务。
    *   因此，所有这些都可以产生中断。答案是 **D. All of the above**。

#### 4. 存储设备与性能

##### 闪存 (Flash Memory)

一种非易失性存储器（断电后数据不丢失），结合了 RAM 和 ROM 的优点。

*   **问题 4 解析**:
    *   B: 它的存储单元是基于 MOSFET（金属氧化物半导体场效应晶体管）的，所以是半导体存储，正确。
    *   C: 非易失性，断电不丢数据，正确。
    *   D: 固态硬盘 (SSD) 就是用闪存做的，可以替代机械硬盘作为外存，正确。
    *   A: 闪存的一个重要特性是**写入速度通常远慢于读取速度**，并且有写入/擦除次数的限制。因此，“读写速度相同”的说法是**错误**的。答案是 **A**。

##### 动态随机存取存储器 (DRAM)

DRAM 是易失性存储器，需要不断刷新来维持数据，但成本低、密度高，是构成计算机**主存 (Main Memory)** 的主要技术。

*   **问题 12 解析**: DRAM 主要用作 **C. 主存 (main memory)**。寄存器和缓存通常使用速度更快但成本更高的 SRAM。

##### 磁盘 I/O 性能

评估磁盘性能时，我们关心两个主要指标：
*   **延迟 (Latency)**: 完成一次 I/O 请求所需的时间。
*   **吞吐量 (Throughput)**: 单位时间内可以传输的数据量。

一次磁盘读/写操作的总时间包括：
*   **排队时间 (Queuing Time)**: 如果磁盘正忙，请求需要等待。
*   **寻道时间 (Seek Time)**: 将磁头移动到目标磁道所需的时间。
*   **旋转延迟 (Rotational Latency)**: 等待磁盘旋转，直到目标扇区的起始位置到达磁头下方。平均旋转延迟是转一圈时间的一半。
*   **传输时间 (Transfer Time)**: 实际读写数据所需的时间。
*   **控制器开销 (Controller Overhead)**: 控制器处理请求所需的时间。

*   **问题 2 解析**: 这个说法是 **正确 (True)** 的。对于处理器，我们更关心执行一条指令需要多长时间（延迟）。但对于 I/O 系统，特别是像磁盘和网络这样的设备，我们通常更关心它在一段时间内能传输多少数据（吞吐量），比如 MB/s。

*   **问题 6 解析**: 计算读取一个扇区的平均时间。
    1.  **题目信息**:
        *   转速: 10,000 RPM (转/分钟)
        *   平均寻道时间: 6 ms
        *   传输速率: 50 MB/sec
        *   控制器开销: 0.2 ms
        *   数据大小: 512 字节
        *   假设磁盘空闲，所以排队时间为 0。

    2.  **计算步骤**:
        *   **平均旋转延迟**:
            *   每分钟转 10,000 次，所以每秒转 $10000 / 60$ 次。
            *   转一圈的时间 = $60 / 10000 = 0.006$ 秒 = $6$ ms。
            *   平均旋转延迟是转一圈时间的一半: $6 \text{ ms} / 2 = 3$ ms。

        *   **传输时间**:
            *   传输时间 = 数据大小 / 传输速率
            *   传输时间 = $512 \text{ B} / (50 \times 10^6 \text{ B/s})$
            *   传输时间 = $10.24 \times 10^{-6}$ 秒 = $0.01024$ ms。这个时间非常短。

        *   **总时间**:
            *   总时间 = 平均寻道时间 + 平均旋转延迟 + 传输时间 + 控制器开销
            *   总时间 = $6 \text{ ms} + 3 \text{ ms} + 0.01024 \text{ ms} + 0.2 \text{ ms}$
            *   总时间 = $9.21024$ ms

    3.  **结论**: 最接近的答案是 **D: 9.21ms**。

> [!TIP] 磁盘访问时间计算公式
> $$
> T_{access} = T_{queue} + T_{seek} + T_{rotation} + T_{transfer} + T_{controller}
> $$
> *   平均旋转延迟 = $\frac{1}{2} \times \frac{60}{\text{RPM}}$
> *   传输时间 = $\frac{\text{数据量}}{\text{传输速率}}$

#### 5. 程序编译与链接

一个程序从源代码到可执行文件需要经历几个阶段：
1.  **预处理器 (Preprocessor)**: 处理宏定义等。
2.  **编译器 (Compiler)**: 将高级语言代码翻译成汇编代码。
3.  **汇编器 (Assembler)**: 将汇编代码翻译成机器码（目标文件），但此时地址可能还是相对的。
4.  **链接器 (Linker)**: 将多个目标文件和库文件组合成一个单一的可执行文件。它的一个重要工作是**地址重定位**，即确定函数和变量的最终内存地址，并计算出所有跳转指令（如分支指令）需要跳转到的确切偏移量或绝对地址。
5.  **加载器 (Loader)**: 当程序运行时，加载器负责将其从磁盘加载到内存中。

*   **问题 11 解析**: 计算分支指令（branch instructions）的偏移量，特别是当这些分支跨越了不同的代码文件时，是在链接阶段完成的。**C. 链接器 (Linker)** 负责解析这些外部引用，并计算出最终的跳转地址。

---

### 答案汇总与总结

1.  **D**: 中断主要是硬件或异常驱动的，用户不能像调用函数一样直接发起。
2.  **T**: I/O 系统更关注数据传输率（吞吐量）。
3.  **A**: I/O 子系统是计算机与外界沟通的桥梁。
4.  **A**: 闪存的写入速度通常远慢于读取速度。
5.  **C**: 设备准备好后主动通知 CPU，这是中断的核心机制。
6.  **D**: 总时间 = 寻道时间 + 旋转延迟 + 传输时间 + 控制器开销 = $6 + (60/10000/2 \times 1000) + (512 / (50 \times 10^6) \times 1000) + 0.2 \approx 9.21$ ms。
7.  **A**: 轮询机制最简单，CPU 不断查询状态寄存器即可，无需特殊硬件。
8.  **D**: 中断返回前必须恢复寄存器的内容和条件码（程序状态），以确保程序能正确继续执行。
9.  **F**: DMA 对于大批量数据传输远比中断高效，因为它解放了 CPU。
10. **D**: 程序错误、硬件故障、I/O 操作都是中断的来源。
11. **C**: 链接器在链接各个模块时，负责解析符号地址并计算跳转偏移。
12. **C**: DRAM 因其高密度和低成本而被广泛用作计算机主存。