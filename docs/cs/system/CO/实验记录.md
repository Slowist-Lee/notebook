
![](Pasted%20image%2020251222113549.png)

![](Pasted%20image%2020251222113601.png)

```
run -all
# Instruction:                 lui  X30, 0x3000
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0010, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=00000000000000000011000000000000, offset=00000000000000000000000000000000
# 
# Instruction:              jalr X31, later(X0)
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0000, ALUSrcA=1, ALUSrcB=10
# Jump=1, JALR=1
# Imm=00000000000000000000000000000000, offset=00000000000000000000000000100000
# 
# Instruction:                 bne  X0, X0, end
# MemtoReg=0, RegWrite=0, MemWrite=0, MemRead=0
# ALUCode=0000, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=00000000000000000000000000011000, offset=00000000000000000000000000011000
# 
# Instruction:                 addi X5, X30, 42
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0000, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=00000000000000000000000001000010, offset=00000000000000000000000000000000
# 
# Instruction:                 add  X6, X0, X31
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0000, ALUSrcA=0, ALUSrcB=00
# Jump=0, JALR=0
# Imm=00000000000000000000000000000000, offset=00000000000000000000000000000000
# 
# Instruction:                  sub  X7, X5, X6
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0001, ALUSrcA=0, ALUSrcB=00
# Jump=0, JALR=0
# Imm=00000000000000000000000000000000, offset=00000000000000000000000000000000
# 
# Instruction:                 or   X28, X7, X5
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0101, ALUSrcA=0, ALUSrcB=00
# Jump=0, JALR=0
# Imm=00000000000000000000000000000000, offset=00000000000000000000000000000000
# 
# Instruction:             beq  X0, X0, earlier
# MemtoReg=0, RegWrite=0, MemWrite=0, MemRead=0
# ALUCode=0000, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=11111111111111111111111111010101, offset=11111111111111111111111111010100
# 
# Instruction:                 sw   X28, 0C(X0)
# MemtoReg=0, RegWrite=0, MemWrite=1, MemRead=0
# ALUCode=0000, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=00000000000000000000000000001100, offset=00000000000000000000000000000000
# 
# Instruction:                 lw   X29, 04(X6)
# MemtoReg=1, RegWrite=1, MemWrite=0, MemRead=1
# ALUCode=0000, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=00000000000000000000000000000100, offset=00000000000000000000000000000000
# 
# Instruction:                  sll  X5, X29, 2
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=0110, ALUSrcA=0, ALUSrcB=01
# Jump=0, JALR=0
# Imm=00000000000000000000000000000010, offset=00000000000000000000000000000000
# 
# Instruction:                 sltu X28, X6, X7
# MemtoReg=0, RegWrite=1, MemWrite=0, MemRead=0
# ALUCode=1010, ALUSrcA=0, ALUSrcB=00
# Jump=0, JALR=0
# Imm=00000000000000000000000000000000, offset=00000000000000000000000000000000
# 
# ** Note: $stop    : D:/MyRepository/study/Junior/co/06-lab/lab30/src/testbench/Decode_tb.v(78)
#    Time: 2600 ns  Iteration: 0  Instance: /Decode_tb
# Break in Module Decode_tb at D:/MyRepository/study/Junior/co/06-lab/lab30/src/testbench/Decode_tb.v line 78
```

## 生成 IP 核的步骤截图

打开的方法：

![](Pasted%20image%2020260103165207.png)

![](Pasted%20image%2020260102224043.png)

![](Pasted%20image%2020260102224052.png)


![](Pasted%20image%2020260102224157.png)
![](Pasted%20image%2020260103165505.png)

debug 修改两个点：

原先的结果：
```bash
run -all
# 
# [TEST 1] System Reset
# Time=15000 -> Reset released. First fetch is from Addr 0.
#   [FAIL] Incorrect instruction fetched. Got 02000fe7
# 
# [TEST 2] Sequential Execution
#   Fetching from Addr 4...
#   [FAIL] Incorrect instruction at Addr 4. Got 01c02623
#   Fetching from Addr 8...
#   [FAIL] Incorrect instruction at Addr 8. Got 00432e83
# 
# [TEST 3] Jump Instruction
#   Asserting Jump, JumpAddr = 2. Next fetch should be from Addr 2.
#   [PASS] Jump successful. Instruction at Addr 2 fetched.
#          Next sequential address calculated is:          3 (from Addr 2 + 4)
#   After Jump, testing sequential fetch from Addr 6...
#   [FAIL] Sequential execution failed after jump. Got 00432e83
# 
# [TEST 4] Branch (Taken)
#   Asserting Branch, TargetAddr = 13. Next fetch should be from Addr 13.
#   [PASS] Branch successful. Instruction at Addr 13 fetched.
#          Next sequential address calculated is:         14 (from Addr 13 + 4)
#   After Branch, testing sequential fetch from Addr 17...
#   [PASS] Sequential execution resumed correctly (fetching default nop).
#          Next sequential address calculated is:         15
# 
# [TEST 5] Branch and Jump Simultaneously
#   Asserting Branch and Jump, TargetAddr = 0.
#   [PASS] Simultaneous Branch/Jump successful.
#          Next sequential address calculated is:          1
# 
# All tests completed.
# ** Note: $stop    : D:/MyRepository/study/Junior/co/06-lab/lab30/src/testbench/IF1_tb.v(155)
#    Time: 106 ns  Iteration: 0  Instance: /IF1_tb
```

第一个问题是第一次取指就fail

这个AI改的没看懂，放弃

第二个是改成字节寻址

错误，直接传递字节地址：

```verilog
InstructionROM u_InstructionROM(
    .addr 	(PC_addr), // 错误：直接传递了字节地址
    .dout 	(PC)
);
```

正确，传递字地址

```verilog
InstructionROM u_InstructionROM(
    .addr 	(PC_addr[7:2]), // 正确：将字节地址转换为字地址
    .dout 	(PC)
);
```

寄存器逻辑：

```markdown
您好，您提出的正是一个数字逻辑设计的核心问题，而好消息是，**您现在的代码已经完美地实现了您想要的功能！**

您不需要做任何修改。您的代码是正确的，并且它已经通过`PC_addr`这个寄存器“保留”了状态到下一个时钟周期。

可能您对其中的工作原理有些困惑，我来为您详细拆解一下，解释为什么您当前的设计是正确的。

### 核心思想：状态寄存器 与 下一状态逻辑

在所有同步数字电路（有`clk`的电路）中，我们都遵循一个最基本的设计模式：
1.  **状态寄存器 (State Register)**：一个或多个寄存器（在您的代码中就是`reg [31:0] PC_addr;`），它们的作用是**“记住”**电路的当前状态。它的值只在时钟上升沿才会改变。
2.  **下一状态组合逻辑 (Next State Combinational Logic)**：一堆组合逻辑电路（在您的代码中就是`adder_32bits`和那个多路选择器`assign NextPC = ...`），它的作用是**根据“当前状态”计算出“下一个时钟沿应该更新成什么状态”**。

您的`NextPC`就是一个**中间信号**，它代表着“下一状态”的计算结果。它本身**不需要**被保留，因为它是一个`wire`，它的值是由输入（`PC_addr`, `Branch`, `Jump`等）随时决定的。

真正负责“保留”和“记忆”功能的，是您的`PC_addr`寄存器。

### 让我们跟随一个时钟周期来看

假设现在时钟刚刚跳变完，电路进入一个稳定的状态，并且当前`PC_addr`的值是`32'd4`。

**第 1 步：组合逻辑立刻计算（在当前时钟周期内，不需要等待）**
*   `PC_addr`（当前状态）的值`4`被送到`adder_32bits`的输入端。
*   `adder_32bits`立刻计算出结果，所以`NextAddr`（输出）的值变成了`4 + 4 = 8`。
*   这个`NextAddr`的值`8`又被送到多路选择器（Mux）的一端。
*   假设现在没有跳转（`Branch=0`, `Jump=0`），`PC_Source`为`0`。
*   多路选择器立刻做出选择，将`NextAddr`的值`8`赋给`NextPC`。

**整个时钟周期内（从当前上升沿到下一个上升沿之前），`PC_addr`的值稳定在`4`，而`NextPC`的值稳定在`8`。** `NextPC`就像一个准备好的、等待加载的“计划”。

**第 2 步：时钟上升沿到来（下一个clk）**
*   当时钟信号从0跳到1的那一瞬间，`always`块被触发。
*   `else`分支被执行：`PC_addr <= NextPC;`。
*   **就在这一刻**，那个“计划好的”值`8`被采样，并被装载进`PC_addr`寄存器。
*   于是，`PC_addr`的值从`4`更新为了`8`。

**第 3 步：进入新的周期**
*   `PC_addr`的值现在是`8`了。
*   组合逻辑**立刻**再次响应这个新的“当前状态”。`adder_32bits`的输出`NextAddr`立刻变成了`8 + 4 = 12`，接着`NextPC`也立刻变成了`12`。
*   电路现在稳定在新的状态：`PC_addr = 8`，`NextPC = 12`，并等待再下一个时钟沿的到来。

### 总结与硬件示意图

您的代码完美地映射到了下面这个经典的硬件结构：



*   **PC_addr** 就是图中的 **"Current State Register"** (当前状态寄存器)。它负责在时钟之间保持值的稳定。
*   **adder_32bits 和 Mux** 就是图中的 **"Combinational Logic"** (组合逻辑)。它们根据当前状态计算下一状态。
*   **NextPC** 就是连接组合逻辑输出和寄存器输入的那根**线 (wire)**。
*   **`always @(posedge clk)`** 块描述了在时钟沿，下一状态 (`NextPC`) 是如何变成新的当前状态 (`PC_addr`) 的。

所以，请放心，您的问题“我应该怎么让他保留到下一个clk”，答案就是：**通过您已经写好的 `PC_addr <= NextPC;` 这条语句，在时钟的驱动下，由 `PC_addr` 这个寄存器来完成保留。** 您的设计是完全正确的。
```


为什么PC_addr开局就是4？

```bash
run -all
# 
# [TEST 1] System Reset
# Time=15000 -> Reset released. First fetch is from Addr 0.
#   [FAIL] Incorrect instruction fetched. Got 02000fe7
# Current PC_addr to be added:          4
#          Next address calculated is:          8
# 
# [TEST 2] Sequential Execution
#   Fetching from Addr 4...
#   [FAIL] Incorrect instruction at Addr 4. Got 01c02623
# Current PC_addr to be added:          8
#          Next address calculated is:         12
#   Fetching from Addr 8...
#   [FAIL] Incorrect instruction at Addr 8. Got 00432e83
# Current PC_addr to be added:         12
#          Next address calculated is:         16
# 
# [TEST 3] Jump Instruction
#   Asserting Jump, JumpAddr = 2. Next fetch should be from Addr 2.
#   [FAIL] Jump failed. Got 00003f37
# Current PC_addr to be added:          2
#          Next address calculated is:          6
#   After Jump, testing sequential fetch from Addr 6...
#   [FAIL] Sequential execution failed after jump. Got 02000fe7
# Current PC_addr to be added:          6
#          Next address calculated is:         10
# 
# [TEST 4] Branch (Taken)
#   Asserting Branch, TargetAddr = 13. Next fetch should be from Addr 13.
#   [FAIL] Branch failed. Got 00432e83
# Current PC_addr to be added:         13
#          Next address calculated is:         17
#   After Branch, testing sequential fetch from Addr 17...
#   [FAIL] Sequential execution failed after branch. Got 002e9293
# Current PC_addr to be added:         17
#          Next address calculated is:         21
# 
# [TEST 5] Branch and Jump Simultaneously
#   Asserting Branch and Jump, TargetAddr = 0.
#   [PASS] Simultaneous Branch/Jump successful.
# Current PC_addr to be added:          0
#          Next address calculated is:          4
# 
# All tests completed.
# ** Note: $stop    : D:/MyRepository/study/Junior/co/06-lab/lab30/src/testbench/IF1_tb.v(180)
#    Time: 106 ns  Iteration: 0  Instance: /IF1_tb
# Break in Module IF1_tb at D:/MyRepository/study/Junior/co/06-lab/lab30/src/testbench/IF1_tb.v line 180

```

然后好像是testbench给错了……

## 总体仿真

别落下：

![](Pasted%20image%2020260103161138.png)

有很多warning，不知道怎么处理

```bash
# ** Warning: (vsim-3017) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(31): [TFMPC] - Too few port connections. Expected 8, found 7.
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/IF_unit File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/IF.v
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(31): [TFMPC] - Missing connection for port 'NextAddr'.
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/IF.v(41): [PCDPC] - Port size (1) does not match connection size (32) for port 'ci'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v(4).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/IF_unit/u_adder_32bits File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/IF.v(41): [PCDPC] - Port size (1) does not match connection size (32) for port 'binvert'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v(7).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/IF_unit/u_adder_32bits File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v
# ** Warning: (vsim-3017) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(40): [TFMPC] - Too few port connections. Expected 13, found 12.
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/ID_unit/Decoder File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Decode.v
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(40): [TFMPC] - Missing connection for port 'ALUCode'.
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(62): [PCDPC] - Port size (5) does not match connection size (1) for port 'ReadRegister1'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Registers.v(7).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/ID_unit/u_Registers File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Registers.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(62): [PCDPC] - Port size (5) does not match connection size (1) for port 'ReadRegister2'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Registers.v(8).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/ID_unit/u_Registers File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Registers.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(62): [PCDPC] - Port size (32) does not match connection size (1) for port 'WriteData'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Registers.v(11).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/ID_unit/u_Registers File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/Registers.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(85): [PCDPC] - Port size (1) does not match connection size (32) for port 'ci'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v(4).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/ID_unit/u_adder_32bits File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/ID.v(85): [PCDPC] - Port size (1) does not match connection size (32) for port 'binvert'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v(7).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/ID_unit/u_adder_32bits File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/adder_32bits.v
# ** Warning: (vsim-3017) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(87): [TFMPC] - Too few port connections. Expected 10, found 8.
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_EX File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/EX.v
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(87): [TFMPC] - Missing connection for port 'ALU_A'.
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(87): [TFMPC] - Missing connection for port 'ALU_B'.
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(102): [PCDPC] - Port size (32) does not match connection size (1) for port 'MemWrite_ex'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/MEM.v(5).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_MEM File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/MEM.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/MEM.v(13): [PCDPC] - Port size (6) does not match connection size (1) for port 'a'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v(57).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_MEM/data File: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/MEM.v(13): [PCDPC] - Port size (32) does not match connection size (1) for port 'd'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v(58).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_MEM/data File: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v
```

仿真乱七八糟，遂开始修warning

```markdown
当然，这份警告列表信息量巨大，而且它们**直接解释了你之前仿真失败的所有原因**。这些不是可以忽略的“可选”警告，而是**灾难性设计错误的明确信号**。

我们来把这些警告分门别类，逐一分析。

---

### 警告类型一：端口连接缺失 (vsim-3017 / vsim-3722)
**含义**：你在实例化一个模块时，没有连接它所有的端口。就像一个芯片，你把它放在电路板上，但有的引脚没有焊上，处于悬空状态。

**1. IF 模块 (IF_unit)**
   *   `Too few port connections. Expected 8, found 7.`
   *   `Missing connection for port 'NextAddr'.`
   *   **分析**：你的 `IF.v` 模块定义了8个端口，但你在 `RISCV_Single.v` 中实例化它时只连接了7个。`NextAddr` 这个输出端口被悬空了。
   *   **影响**：虽然在你的顶层设计中可能暂时没用到 `NextAddr`，但这是一个不好的实践。更重要的是，它表明你可能对 `IF` 模块的设计意图理解不清晰。

**2. ID 模块内部的译码器 (ID_unit/Decoder)**
   *   `Too few port connections. Expected 13, found 12.`
   *   `Missing connection for port 'ALUCode'.`
   *   **分析**：这是**一个致命错误**。在你的 `ID.v` 文件中，你实例化了译码器 `Decoder`，但没有连接它的 `ALUCode` 输出端口。
   *   **影响**：`ALUCode` 是用来告诉ALU执行哪种运算（加、减、或、与等）的关键控制信号。由于你没有连接它，`ID` 模块输出的 `ALUCode_id` 信号将是一个**不确定值（X）**。这个 `X` 值传递给EX阶段后，ALU完全不知道要做什么，其计算结果 `ALUResult_ex` 自然也是 `X`。**这就解释了为什么你的所有计算和跳转都是错误的，并且最终PC也变成了 `X`**。

**3. EX 模块 (u_EX)**
   *   `Too few port connections. Expected 10, found 8.`
   *   `Missing connection for port 'ALU_A'.`
   *   `Missing connection for port 'ALU_B'.`
   *   **分析**：你在 `RISCV_Single.v` 中实例化 `u_EX` 时，漏掉了 `ALU_A` 和 `ALU_B` 这两个端口的连接。
   *   **影响**：这同样是**致命的**。这两个信号很可能是ALU的最终操作数输入。如果它们没有被连接，ALU将用不确定的输入（X）进行运算，结果自然也是 `X`。

---

### 警告类型二：端口位宽不匹配 (vsim-3015)
**含义**：你正在尝试将一个 `N` 位的线连接到一个 `M` 位的端口上（`N` 不等于 `M`）。例如，把一根32位的总线硬塞到一个只有1位的插槽里。仿真器只会取其中的1位（通常是最低位），剩下的31位全部丢弃，这会导致数据严重错误。

**1. 加法器 (adder_32bits)**
   *   `Port size (1) does not match connection size (32) for port 'ci' / 'binvert'.`
   *   **分析**：在 `IF.v` 和 `ID.v` 中，你实例化的32位加法器的 `ci`（进位输入）和 `binvert`（反转输入B，用于减法）端口都只有1位宽，但你错误地将一个32位的信号连接了上去。
   *   **影响**：加法器的行为将变得不可预测，因为它只取了那个32位信号的第0位作为控制信号。

**2. 寄存器文件 (ID_unit/u_Registers)**
   *   `Port size (5) does not match connection size (1) for port 'ReadRegister1' / 'ReadRegister2'.`
   *   `Port size (32) does not match connection size (1) for port 'WriteData'.`
   *   **分析**：这是**灾难性的错误**，完全破坏了寄存器文件的功能。
   *   **影响**：
      *   读地址 `ReadRegister1/2` 需要5位宽才能从32个寄存器中选择一个。你只连接了1位，意味着你的CPU**永远只能读取0号或1号寄存器**。
      *   写数据 `WriteData` 需要32位宽。你只连接了1位，意味着你**永远只能把 `0` 或 `1` 写入寄存器**，而不是完整的32位计算结果。**这完美解释了为什么你的 `[FAIL] No register write back` 日志中，写回的数据永远不可能是对的。**

**3. MEM 模块和 DataRAM IP核**
   *   `Port size (32) does not match connection size (1) for port 'MemWrite_ex'.`
   *   `Port size (6) does not match connection size (1) for port 'a'.`
   *   `Port size (32) does not match connection size (1) for port 'd'.`
   *   **分析**：同样是灾难性的位宽不匹配。
   *   **影响**：
      *   `MEM` 模块的写使能信号 `MemWrite_ex` 应该是1位，你却连了个32位的。
      *   `DataRAM` 的地址端口 `a` 需要6位（因为你的RAM深度是64=2^6），你却连了1位。这意味着**永远只能访问0号或1号内存地址**。
      *   `DataRAM` 的写入数据端口 `d` 需要32位，你却连了1位。这意味着**永远只能把1位的数据写入内存**。**这就解释了为什么你的 `sw` 指令彻底失败。**

---

### 总结与修复指南

**你的CPU之所以完全不工作，不是因为某个细微的逻辑错误，而是因为整个设计的“电路连接”就是错误的。** 这些警告已经把问题的根源全部告诉你了。

**请按以下优先级，立刻修复这些问题：**

1.  **修复最致命的连接缺失**：
    *   **进入 `ID.v` 文件**，找到你实例化 `Decoder` 的地方，**把 `ALUCode` 端口正确连接出来**。这是让ALU工作的先决条件。

2.  **修复所有位宽不匹配问题 (vsim-3015)**：
    *   **仔细检查 `ID.v` 中实例化 `Registers` 的代码**。确保连接到 `ReadRegister1/2` 的是5位宽的 `rs1Addr/rs2Addr` 信号，连接到 `WriteData` 的是32位宽的 `RegWriteData_wb` 信号。
    *   **检查 `MEM.v` 中实例化 `DataRAM` 的代码**。确保地址 `a` 连接的是 `ALUResult_mem[7:2]` 这样的6位信号，数据 `d` 连接的是32位的写数据信号。
    *   **检查所有 `adder_32bits` 的实例化**。确保 `ci` 和 `binvert` 连接的是 `1'b0` 或其他单比特信号。

3.  **修复其他连接缺失**：
    *   检查 `EX.v` 的代码，看看 `ALU_A` 和 `ALU_B` 到底是什么。如果它们是ALU的输入，就必须在 `RISCV_Single.v` 中正确连接它们（通常来自ALU的输入选择Mux）。
    *   给 `IF_unit` 的 `NextAddr` 端口创建一个 `wire` 并连接上，即使暂时不用。

**调试建议**：
**先不要运行仿真了。** 你的首要任务是**静态代码检查**。逐个处理掉列表中的每一个警告。当你重新编译/综合时，确保**没有任何警告**（或者你完全理解并接受了每一个警告）。在一个干净、没有连接警告的设计基础上，再去进行功能仿真和波形调试，才有意义。
```

然后发现是自己的变量名和定义一堆写错了……修改结束

出现了新的warning！

```bash
# Loading work.WB
# ** Warning: (vsim-3017) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(31): [TFMPC] - Too few port connections. Expected 8, found 7.
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/IF_unit File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/IF.v
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(31): [TFMPC] - Missing connection for port 'NextAddr'.
# ** Warning: (vsim-3017) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(87): [TFMPC] - Too few port connections. Expected 10, found 8.
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_EX File: D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/EX.v
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(87): [TFMPC] - Missing connection for port 'ALU_A'.
# ** Warning: (vsim-3722) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/RISCV_Single.v(87): [TFMPC] - Missing connection for port 'ALU_B'.
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/MEM.v(13): [PCDPC] - Port size (6) does not match connection size (1) for port 'a'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v(57).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_MEM/data File: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v
# ** Warning: (vsim-3015) D:/MyRepository/study/Junior/co/06-lab/lab30/src/code/MEM.v(13): [PCDPC] - Port size (32) does not match connection size (1) for port 'd'. The port definition is at: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v(58).
#    Time: 0 ps  Iteration: 0  Instance: /RISCV_Single_tb/u_riscv_cpu/u_MEM/data File: D:/MyRepository/study/Junior/co/06-lab/lab30/vivado/Risc5CPU.srcs/sources_1/ip/DataRAM/sim/DataRAM.v

```

发现自己的仿真核有点问题，modelsim10.4和vivado2017.4有可能不兼容，导致xilinx编译不出来。暂时不知道咋解决

写了ID\_tb.v，跑仿真

```bash

[TEST 1] Pre-loading registers x1 and x2 for subsequent tests.
  -> Wrote         10 to register x 1.
  -> Wrote         20 to register x 2.

[TEST 2] R-Type instruction: ADD x3, x1, x2
  -> Read Data: rs1Data=        10 (expected 10), rs2Data=        20 (expected 20)
  -> [PASS] Correctly read values from register file.

[TEST 3] Data Hazard Simulation (Read-After-Write)
  -> SCENARIO: WB stage is writing 999 to x5.
  ->           ID stage is reading x5 with instruction `add x6, x5, x0`.
  -> At the clock edge, register file was written to and read from.
  -> Data read for rs1 (x5) was:        999
  -> [FAIL] Incorrectly read the NEW value of x5 (       999). This indicates a logic error.
  -> In the NEXT cycle, reading x5 again...
  -> Data read for rs1 (x5) is now:        999
  -> [PASS] The new value (999) is now correctly available.

[TEST 4] S-Type instruction: SW x2, 16(x1)
  -> Outputs: MemWrite=1, RegWrite=0, Imm=        16
  -> Read Data: base(x1)=        10, data(x2)=        20
  -> [PASS] Control signals and data for SW are correct.

[TEST 5] B-Type instruction: BEQ x1, x2, offset (not taken)
  -> Outputs: Branch=0, JumpAddr=0x00002014
  -> [PASS] Branch signal is correctly 0 for unequal values.

Simulation Finished.
INFO: [USF-XSim-96] XSim completed. Design snapshot 'ID_tb_behav' loaded.
INFO: [USF-XSim-97] XSim simulation ran for 1000ns
launch_simulation: Time (s): cpu = 00:00:01 ; elapsed = 00:00:08 . Memory (MB): peak = 965.859 ; gain = 14.320
```